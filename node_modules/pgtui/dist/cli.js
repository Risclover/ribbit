#!/usr/bin/env node
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/tsup/assets/cjs_shims.js
var init_cjs_shims = __esm({
  "node_modules/tsup/assets/cjs_shims.js"() {
  }
});

// node_modules/glob-option-error/index.js
var require_glob_option_error = __commonJS({
  "node_modules/glob-option-error/index.js"(exports, module2) {
    "use strict";
    init_cjs_shims();
    var { inspect } = require("util");
    var isTypeError = (err) => err.name === "TypeError";
    var createMessageLine = (msg, err, index) => `${msg}
  ${index + 1}. ${err.message}`;
    module2.exports = function GlobOptionError(...args) {
      const argLen = args.length;
      if (argLen !== 1) {
        throw new TypeError(`Expected 1 argument (Array<errors>), but got ${argLen || "no"} arguments.`);
      }
      const [arr] = args;
      if (!Array.isArray(arr)) {
        throw new TypeError(`Expected an array of errors, but got a non-array value ${inspect(arr)}.`);
      }
      const count = arr.length;
      if (count === 0) {
        throw new RangeError("Expected an array with at least one error, but got [] (empty array).");
      }
      if (count === 1) {
        arr[0][Symbol.iterator] = function* () {
          yield arr[0];
        };
        return arr[0];
      }
      const error = new (arr.every(isTypeError) ? TypeError : Error)(arr.reduce(createMessageLine, `${count} errors found in the glob options:`));
      error[Symbol.iterator] = function* () {
        for (const result of arr) {
          yield result;
        }
      };
      return error;
    };
  }
});

// node_modules/array-to-sentence/index.js
var require_array_to_sentence = __commonJS({
  "node_modules/array-to-sentence/index.js"(exports, module2) {
    init_cjs_shims();
    module2.exports = function arrayToSentence(arr, options) {
      "use strict";
      if (!Array.isArray(arr)) {
        throw new TypeError(String(arr) + " is not an array. Expected an array.");
      }
      options = options || {};
      function validateOption(optionName) {
        if (typeof options[optionName] !== "string") {
          throw new TypeError(String(options[optionName]) + " is not a string. `" + optionName + "` option must be a string.");
        }
      }
      if (options.separator === void 0) {
        options.separator = ", ";
      } else {
        validateOption("separator");
      }
      if (options.lastSeparator === void 0) {
        options.lastSeparator = " and ";
      } else {
        validateOption("lastSeparator");
      }
      if (arr.length === 0) {
        return "";
      }
      if (arr.length === 1) {
        return arr[0];
      }
      return arr.slice(0, -1).join(options.separator) + options.lastSeparator + arr[arr.length - 1];
    };
  }
});

// node_modules/is-plain-obj/index.js
var require_is_plain_obj = __commonJS({
  "node_modules/is-plain-obj/index.js"(exports, module2) {
    "use strict";
    init_cjs_shims();
    var toString = Object.prototype.toString;
    module2.exports = function(x) {
      var prototype;
      return toString.call(x) === "[object Object]" && (prototype = Object.getPrototypeOf(x), prototype === null || prototype === Object.getPrototypeOf({}));
    };
  }
});

// node_modules/append-type/index.mjs
function appendType(val) {
  if (val === void 0) {
    return "undefined";
  }
  if (val === null) {
    return "null";
  }
  return String(val) + " (" + typeof val + ")";
}
var init_append_type = __esm({
  "node_modules/append-type/index.mjs"() {
    init_cjs_shims();
  }
});

// node_modules/indexed-filter/index.mjs
var indexed_filter_exports = {};
__export(indexed_filter_exports, {
  default: () => indexedFilter
});
function indexedFilter(arr, fn, thisObj) {
  if (!Array.isArray(arr)) {
    throw new TypeError("Expected an array to be filtered, but got a non-array value " + appendType(arr) + ".");
  }
  if (typeof fn !== "function") {
    throw new TypeError("Expected a filter function, but got a non-function value " + appendType(fn) + ".");
  }
  var results = [];
  arr.forEach(function(v, i, arrayItself) {
    if (fn.call(this, v, i, arrayItself)) {
      results.push({
        index: i,
        value: v
      });
    }
  }, thisObj);
  return results;
}
var init_indexed_filter = __esm({
  "node_modules/indexed-filter/index.mjs"() {
    init_cjs_shims();
    init_append_type();
  }
});

// node_modules/kind-of/index.js
var require_kind_of = __commonJS({
  "node_modules/kind-of/index.js"(exports, module2) {
    init_cjs_shims();
    var toString = Object.prototype.toString;
    module2.exports = function kindOf(val) {
      if (val === void 0)
        return "undefined";
      if (val === null)
        return "null";
      var type = typeof val;
      if (type === "boolean")
        return "boolean";
      if (type === "string")
        return "string";
      if (type === "number")
        return "number";
      if (type === "symbol")
        return "symbol";
      if (type === "function") {
        return isGeneratorFn(val) ? "generatorfunction" : "function";
      }
      if (isArray(val))
        return "array";
      if (isBuffer(val))
        return "buffer";
      if (isArguments(val))
        return "arguments";
      if (isDate(val))
        return "date";
      if (isError(val))
        return "error";
      if (isRegexp(val))
        return "regexp";
      switch (ctorName(val)) {
        case "Symbol":
          return "symbol";
        case "Promise":
          return "promise";
        case "WeakMap":
          return "weakmap";
        case "WeakSet":
          return "weakset";
        case "Map":
          return "map";
        case "Set":
          return "set";
        case "Int8Array":
          return "int8array";
        case "Uint8Array":
          return "uint8array";
        case "Uint8ClampedArray":
          return "uint8clampedarray";
        case "Int16Array":
          return "int16array";
        case "Uint16Array":
          return "uint16array";
        case "Int32Array":
          return "int32array";
        case "Uint32Array":
          return "uint32array";
        case "Float32Array":
          return "float32array";
        case "Float64Array":
          return "float64array";
      }
      if (isGeneratorObj(val)) {
        return "generator";
      }
      type = toString.call(val);
      switch (type) {
        case "[object Object]":
          return "object";
        case "[object Map Iterator]":
          return "mapiterator";
        case "[object Set Iterator]":
          return "setiterator";
        case "[object String Iterator]":
          return "stringiterator";
        case "[object Array Iterator]":
          return "arrayiterator";
      }
      return type.slice(8, -1).toLowerCase().replace(/\s/g, "");
    };
    function ctorName(val) {
      return typeof val.constructor === "function" ? val.constructor.name : null;
    }
    function isArray(val) {
      if (Array.isArray)
        return Array.isArray(val);
      return val instanceof Array;
    }
    function isError(val) {
      return val instanceof Error || typeof val.message === "string" && val.constructor && typeof val.constructor.stackTraceLimit === "number";
    }
    function isDate(val) {
      if (val instanceof Date)
        return true;
      return typeof val.toDateString === "function" && typeof val.getDate === "function" && typeof val.setDate === "function";
    }
    function isRegexp(val) {
      if (val instanceof RegExp)
        return true;
      return typeof val.flags === "string" && typeof val.ignoreCase === "boolean" && typeof val.multiline === "boolean" && typeof val.global === "boolean";
    }
    function isGeneratorFn(name, val) {
      return ctorName(name) === "GeneratorFunction";
    }
    function isGeneratorObj(val) {
      return typeof val.throw === "function" && typeof val.return === "function" && typeof val.next === "function";
    }
    function isArguments(val) {
      try {
        if (typeof val.length === "number" && typeof val.callee === "function") {
          return true;
        }
      } catch (err) {
        if (err.message.indexOf("callee") !== -1) {
          return true;
        }
      }
      return false;
    }
    function isBuffer(val) {
      if (val.constructor && typeof val.constructor.isBuffer === "function") {
        return val.constructor.isBuffer(val);
      }
      return false;
    }
  }
});

// node_modules/inspect-with-kind/index.js
var require_inspect_with_kind = __commonJS({
  "node_modules/inspect-with-kind/index.js"(exports, module2) {
    "use strict";
    init_cjs_shims();
    var inspect = require("util").inspect;
    var kindOf = require_kind_of();
    var appendedKinds = /* @__PURE__ */ new Set([
      "arguments",
      "array",
      "bigint",
      "boolean",
      "date",
      "number",
      "object",
      "regexp",
      "string"
    ]);
    module2.exports = function inspectWithKind(val, options) {
      const kind = kindOf(val);
      const stringifiedVal = inspect(val, Object.assign({
        breakLength: Infinity,
        maxArrayLength: 10
      }, options));
      if (kind === "error") {
        return val.toString();
      }
      if (!appendedKinds.has(kind)) {
        return stringifiedVal;
      }
      if (stringifiedVal.startsWith("Observable {")) {
        return stringifiedVal;
      }
      return `${stringifiedVal} (${kind})`;
    };
  }
});

// node_modules/validate-glob-opts/index.js
var require_validate_glob_opts = __commonJS({
  "node_modules/validate-glob-opts/index.js"(exports, module2) {
    "use strict";
    init_cjs_shims();
    var { inspect } = require("util");
    var arrayToSentence = require_array_to_sentence();
    var isPlainObj = require_is_plain_obj();
    var indexedFilter2 = (init_indexed_filter(), __toCommonJS(indexed_filter_exports));
    var inspectWithKind = require_inspect_with_kind();
    var ERROR_MESSAGE = "Expected node-glob options to be an object";
    var INVALID_CACHE_MESSAGE = "Expected every value in the `cache` option to be true, false, 'FILE', 'DIR' or an array";
    var INVALID_STAT_CACHE_MESSAGE = "Expected every value in the `statCache` option to be a fs.Stats instance";
    var pathOptions = /* @__PURE__ */ new Set(["cwd", "root"]);
    var booleanOptions = /* @__PURE__ */ new Set([
      "dot",
      "nomount",
      "mark",
      "nosort",
      "stat",
      "silent",
      "strict",
      "nounique",
      "nonull",
      "debug",
      "nobrace",
      "noglobstar",
      "noext",
      "nocase",
      "matchBase",
      "nodir",
      "follow",
      "realpath",
      "absolute"
    ]);
    var typos = /* @__PURE__ */ new Map([
      ["noMount", "nomount"],
      ["nouniq", "nounique"],
      ["noUnique", "nounique"],
      ["noNull", "nonull"],
      ["noBrace", "nobrace"],
      ["noGlobStar", "noglobstar"],
      ["noExt", "noext"],
      ["noCase", "nocase"],
      ["matchbase", "matchBase"],
      ["noDir", "nodir"],
      ["realPath", "realpath"],
      ["realPathCache", "realpathCache"],
      ["realpathCaches", "realpathCache"],
      ["realPathCaches", "realpathCache"],
      ["caches", "cache"],
      ["statcache", "statCache"],
      ["statCaches", "statCache"],
      ["symlink", "symlinks"]
    ]);
    var isNonFn = (val) => typeof val !== "function";
    var stringifyFilterResult = (obj) => `${inspect(obj.value)} (at ${obj.index})`;
    module2.exports = function validateGlobOpts(...args) {
      const argLen = args.length;
      if (argLen > 2) {
        throw new TypeError(`Expected 0, 1 or 2 arguments ([<object>, <array>]), but got ${argLen}.`);
      }
      const [obj, additionalValidations] = args;
      if (argLen === 2) {
        if (!Array.isArray(additionalValidations)) {
          throw new TypeError(`Expected an array of functions, but got a non-array value ${inspectWithKind(additionalValidations)}.`);
        }
        const nonFunctions = indexedFilter2(additionalValidations, isNonFn);
        const nonFunctionCount = nonFunctions.length;
        if (nonFunctionCount !== 0) {
          throw new TypeError(`Expected every element in the array to be a function, but found ${nonFunctionCount === 1 ? "a non-function value" : "non-function values"} in the array: ${arrayToSentence(nonFunctions.map(stringifyFilterResult))}.`);
        }
      }
      if (obj === "") {
        return [new TypeError(`${ERROR_MESSAGE}, but got '' (empty string).`)];
      }
      if (!obj) {
        return [];
      }
      if (typeof obj !== "object" || Array.isArray(obj)) {
        return [new TypeError(`${ERROR_MESSAGE}, but got ${inspectWithKind(obj)}.`)];
      }
      const results = [];
      if (obj.sync !== void 0) {
        results.push(new Error(`\`sync\` option is deprecated and there\u2019s no need to pass any values to that option, but ${inspect(obj.sync)} was provided.`));
      }
      for (const prop of pathOptions) {
        const val = obj[prop];
        if (val !== void 0 && typeof obj[prop] !== "string") {
          results.push(new TypeError(`node-glob expected \`${prop}\` option to be a directory path (string), but got ${inspectWithKind(val)}.`));
        }
      }
      for (const prop of booleanOptions) {
        const val = obj[prop];
        if (val !== void 0 && typeof obj[prop] !== "boolean") {
          results.push(new TypeError(`node-glob expected \`${prop}\` option to be a Boolean value, but got ${inspectWithKind(val)}.`));
        }
      }
      if (obj.nodir === true) {
        if (obj.mark === true) {
          results.push(new TypeError("Expected `mark` option not to be `true` when `nodir` option is `true`, because there is no need to differentiate directory paths from file paths when `nodir` option is enabled, but got `true`."));
        }
      }
      if (obj.cache !== void 0) {
        if (!isPlainObj(obj.cache)) {
          results.push(new TypeError(`node-glob expected \`cache\` option to be an object, but got ${inspectWithKind(obj.cache)}.`));
        } else {
          for (const field of Object.keys(obj.cache)) {
            const val = obj.cache[field];
            if (typeof val !== "string") {
              if (typeof val !== "boolean" && !Array.isArray(val)) {
                results.push(new TypeError(`${INVALID_CACHE_MESSAGE}, but found an invalid value ${inspectWithKind(val)} in \`${field}\` property.`));
              }
            } else if (val !== "FILE" && val !== "DIR") {
              results.push(new Error(`${INVALID_CACHE_MESSAGE}, but found an invalid string ${inspect(val)} in \`${field}\` property.`));
            }
          }
        }
      }
      if (obj.realpathCache !== void 0) {
        if (!isPlainObj(obj.realpathCache)) {
          results.push(new TypeError(`node-glob expected \`realpathCache\` option to be an object, but got ${inspectWithKind(obj.realpathCache)}.`));
        } else {
          for (const field of Object.keys(obj.realpathCache)) {
            const val = obj.realpathCache[field];
            if (typeof val !== "string") {
              results.push(new TypeError(`Expected every value in the \`realpathCache\` option to be a string, but found a non-string value ${inspectWithKind(val)} in \`${field}\` property.`));
            }
          }
        }
      }
      if (obj.statCache !== void 0) {
        if (!isPlainObj(obj.statCache)) {
          results.push(new TypeError(`node-glob expected \`statCache\` option to be an object, but got ${inspectWithKind(obj.statCache)}.`));
        } else {
          for (const field of Object.keys(obj.statCache)) {
            const val = obj.statCache[field];
            if (val === null || typeof val !== "object" || Array.isArray(val)) {
              results.push(new TypeError(`${INVALID_STAT_CACHE_MESSAGE}, but found an invalid value ${inspect(val)} in \`${field}\` property.`));
            } else if (typeof val.mode !== "number") {
              results.push(new Error(`${INVALID_STAT_CACHE_MESSAGE}, but found an invalid object ${inspect(val)} in \`${field}\` property, which doesn't have a valid file mode.`));
            }
          }
        }
      }
      if (obj.symlinks !== void 0) {
        if (!isPlainObj(obj.symlinks)) {
          results.push(new TypeError(`node-glob expected \`symlinks\` option to be an object, but got ${inspectWithKind(obj.symlinks)}.`));
        } else {
          for (const field of Object.keys(obj.symlinks)) {
            const val = obj.symlinks[field];
            if (typeof val !== "boolean") {
              results.push(new TypeError(`Expected every value in the \`symlink\` option to be Boolean, but found an invalid value ${inspectWithKind(val)} in \`${field}\` property.`));
            }
          }
        }
      }
      if (obj.ignore !== void 0) {
        if (!Array.isArray(obj.ignore)) {
          if (typeof obj.ignore !== "string") {
            results.push(new TypeError(`node-glob expected \`ignore\` option to be an array or string, but got ${inspectWithKind(obj.ignore)}.`));
          }
        } else {
          for (const val of obj.ignore) {
            if (typeof val !== "string") {
              results.push(new TypeError(`Expected every value in the \`ignore\` option to be a string, but the array includes a non-string value ${inspectWithKind(val)}.`));
            }
          }
        }
      }
      for (const key of Object.keys(obj)) {
        const correctName = typos.get(key);
        if (correctName !== void 0) {
          results.push(new Error(`node-glob doesn't have \`${key}\` option. Probably you meant \`${correctName}\`.`));
        }
      }
      for (const fn of additionalValidations || []) {
        const additionalResult = fn(obj);
        if (additionalResult) {
          if (!(additionalResult instanceof Error)) {
            throw new TypeError(`Expected an additional validation function to return an error, but returned ${inspectWithKind(additionalResult)}.`);
          }
          results.push(additionalResult);
        }
      }
      return results;
    };
  }
});

// node_modules/assert-valid-glob-opts/index.js
var require_assert_valid_glob_opts = __commonJS({
  "node_modules/assert-valid-glob-opts/index.js"(exports, module2) {
    "use strict";
    init_cjs_shims();
    var GlobOptionError = require_glob_option_error();
    var validateGlobOpts = require_validate_glob_opts();
    module2.exports = function assertValidGlobOpts(...args) {
      const results = validateGlobOpts(...args);
      if (results.length === 0) {
        return;
      }
      throw new GlobOptionError(results);
    };
  }
});

// node_modules/graceful-fs/polyfills.js
var require_polyfills = __commonJS({
  "node_modules/graceful-fs/polyfills.js"(exports, module2) {
    init_cjs_shims();
    var constants = require("constants");
    var origCwd = process.cwd;
    var cwd = null;
    var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
    process.cwd = function() {
      if (!cwd)
        cwd = origCwd.call(process);
      return cwd;
    };
    try {
      process.cwd();
    } catch (er) {
    }
    if (typeof process.chdir === "function") {
      chdir = process.chdir;
      process.chdir = function(d) {
        cwd = null;
        chdir.call(process, d);
      };
      if (Object.setPrototypeOf)
        Object.setPrototypeOf(process.chdir, chdir);
    }
    var chdir;
    module2.exports = patch;
    function patch(fs3) {
      if (constants.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
        patchLchmod(fs3);
      }
      if (!fs3.lutimes) {
        patchLutimes(fs3);
      }
      fs3.chown = chownFix(fs3.chown);
      fs3.fchown = chownFix(fs3.fchown);
      fs3.lchown = chownFix(fs3.lchown);
      fs3.chmod = chmodFix(fs3.chmod);
      fs3.fchmod = chmodFix(fs3.fchmod);
      fs3.lchmod = chmodFix(fs3.lchmod);
      fs3.chownSync = chownFixSync(fs3.chownSync);
      fs3.fchownSync = chownFixSync(fs3.fchownSync);
      fs3.lchownSync = chownFixSync(fs3.lchownSync);
      fs3.chmodSync = chmodFixSync(fs3.chmodSync);
      fs3.fchmodSync = chmodFixSync(fs3.fchmodSync);
      fs3.lchmodSync = chmodFixSync(fs3.lchmodSync);
      fs3.stat = statFix(fs3.stat);
      fs3.fstat = statFix(fs3.fstat);
      fs3.lstat = statFix(fs3.lstat);
      fs3.statSync = statFixSync(fs3.statSync);
      fs3.fstatSync = statFixSync(fs3.fstatSync);
      fs3.lstatSync = statFixSync(fs3.lstatSync);
      if (!fs3.lchmod) {
        fs3.lchmod = function(path2, mode, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs3.lchmodSync = function() {
        };
      }
      if (!fs3.lchown) {
        fs3.lchown = function(path2, uid, gid, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs3.lchownSync = function() {
        };
      }
      if (platform === "win32") {
        fs3.rename = function(fs$rename) {
          return function(from, to, cb) {
            var start = Date.now();
            var backoff = 0;
            fs$rename(from, to, function CB(er) {
              if (er && (er.code === "EACCES" || er.code === "EPERM") && Date.now() - start < 6e4) {
                setTimeout(function() {
                  fs3.stat(to, function(stater, st) {
                    if (stater && stater.code === "ENOENT")
                      fs$rename(from, to, CB);
                    else
                      cb(er);
                  });
                }, backoff);
                if (backoff < 100)
                  backoff += 10;
                return;
              }
              if (cb)
                cb(er);
            });
          };
        }(fs3.rename);
      }
      fs3.read = function(fs$read) {
        function read(fd, buffer, offset, length, position, callback_) {
          var callback;
          if (callback_ && typeof callback_ === "function") {
            var eagCounter = 0;
            callback = function(er, _, __) {
              if (er && er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                return fs$read.call(fs3, fd, buffer, offset, length, position, callback);
              }
              callback_.apply(this, arguments);
            };
          }
          return fs$read.call(fs3, fd, buffer, offset, length, position, callback);
        }
        if (Object.setPrototypeOf)
          Object.setPrototypeOf(read, fs$read);
        return read;
      }(fs3.read);
      fs3.readSync = function(fs$readSync) {
        return function(fd, buffer, offset, length, position) {
          var eagCounter = 0;
          while (true) {
            try {
              return fs$readSync.call(fs3, fd, buffer, offset, length, position);
            } catch (er) {
              if (er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                continue;
              }
              throw er;
            }
          }
        };
      }(fs3.readSync);
      function patchLchmod(fs4) {
        fs4.lchmod = function(path2, mode, callback) {
          fs4.open(path2, constants.O_WRONLY | constants.O_SYMLINK, mode, function(err, fd) {
            if (err) {
              if (callback)
                callback(err);
              return;
            }
            fs4.fchmod(fd, mode, function(err2) {
              fs4.close(fd, function(err22) {
                if (callback)
                  callback(err2 || err22);
              });
            });
          });
        };
        fs4.lchmodSync = function(path2, mode) {
          var fd = fs4.openSync(path2, constants.O_WRONLY | constants.O_SYMLINK, mode);
          var threw = true;
          var ret;
          try {
            ret = fs4.fchmodSync(fd, mode);
            threw = false;
          } finally {
            if (threw) {
              try {
                fs4.closeSync(fd);
              } catch (er) {
              }
            } else {
              fs4.closeSync(fd);
            }
          }
          return ret;
        };
      }
      function patchLutimes(fs4) {
        if (constants.hasOwnProperty("O_SYMLINK")) {
          fs4.lutimes = function(path2, at, mt, cb) {
            fs4.open(path2, constants.O_SYMLINK, function(er, fd) {
              if (er) {
                if (cb)
                  cb(er);
                return;
              }
              fs4.futimes(fd, at, mt, function(er2) {
                fs4.close(fd, function(er22) {
                  if (cb)
                    cb(er2 || er22);
                });
              });
            });
          };
          fs4.lutimesSync = function(path2, at, mt) {
            var fd = fs4.openSync(path2, constants.O_SYMLINK);
            var ret;
            var threw = true;
            try {
              ret = fs4.futimesSync(fd, at, mt);
              threw = false;
            } finally {
              if (threw) {
                try {
                  fs4.closeSync(fd);
                } catch (er) {
                }
              } else {
                fs4.closeSync(fd);
              }
            }
            return ret;
          };
        } else {
          fs4.lutimes = function(_a, _b, _c, cb) {
            if (cb)
              process.nextTick(cb);
          };
          fs4.lutimesSync = function() {
          };
        }
      }
      function chmodFix(orig) {
        if (!orig)
          return orig;
        return function(target, mode, cb) {
          return orig.call(fs3, target, mode, function(er) {
            if (chownErOk(er))
              er = null;
            if (cb)
              cb.apply(this, arguments);
          });
        };
      }
      function chmodFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, mode) {
          try {
            return orig.call(fs3, target, mode);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function chownFix(orig) {
        if (!orig)
          return orig;
        return function(target, uid, gid, cb) {
          return orig.call(fs3, target, uid, gid, function(er) {
            if (chownErOk(er))
              er = null;
            if (cb)
              cb.apply(this, arguments);
          });
        };
      }
      function chownFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, uid, gid) {
          try {
            return orig.call(fs3, target, uid, gid);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function statFix(orig) {
        if (!orig)
          return orig;
        return function(target, options, cb) {
          if (typeof options === "function") {
            cb = options;
            options = null;
          }
          function callback(er, stats) {
            if (stats) {
              if (stats.uid < 0)
                stats.uid += 4294967296;
              if (stats.gid < 0)
                stats.gid += 4294967296;
            }
            if (cb)
              cb.apply(this, arguments);
          }
          return options ? orig.call(fs3, target, options, callback) : orig.call(fs3, target, callback);
        };
      }
      function statFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, options) {
          var stats = options ? orig.call(fs3, target, options) : orig.call(fs3, target);
          if (stats.uid < 0)
            stats.uid += 4294967296;
          if (stats.gid < 0)
            stats.gid += 4294967296;
          return stats;
        };
      }
      function chownErOk(er) {
        if (!er)
          return true;
        if (er.code === "ENOSYS")
          return true;
        var nonroot = !process.getuid || process.getuid() !== 0;
        if (nonroot) {
          if (er.code === "EINVAL" || er.code === "EPERM")
            return true;
        }
        return false;
      }
    }
  }
});

// node_modules/graceful-fs/legacy-streams.js
var require_legacy_streams = __commonJS({
  "node_modules/graceful-fs/legacy-streams.js"(exports, module2) {
    init_cjs_shims();
    var Stream = require("stream").Stream;
    module2.exports = legacy;
    function legacy(fs3) {
      return {
        ReadStream,
        WriteStream
      };
      function ReadStream(path2, options) {
        if (!(this instanceof ReadStream))
          return new ReadStream(path2, options);
        Stream.call(this);
        var self = this;
        this.path = path2;
        this.fd = null;
        this.readable = true;
        this.paused = false;
        this.flags = "r";
        this.mode = 438;
        this.bufferSize = 64 * 1024;
        options = options || {};
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.encoding)
          this.setEncoding(this.encoding);
        if (this.start !== void 0) {
          if (typeof this.start !== "number") {
            throw TypeError("start must be a Number");
          }
          if (this.end === void 0) {
            this.end = Infinity;
          } else if (typeof this.end !== "number") {
            throw TypeError("end must be a Number");
          }
          if (this.start > this.end) {
            throw new Error("start must be <= end");
          }
          this.pos = this.start;
        }
        if (this.fd !== null) {
          process.nextTick(function() {
            self._read();
          });
          return;
        }
        fs3.open(this.path, this.flags, this.mode, function(err, fd) {
          if (err) {
            self.emit("error", err);
            self.readable = false;
            return;
          }
          self.fd = fd;
          self.emit("open", fd);
          self._read();
        });
      }
      function WriteStream(path2, options) {
        if (!(this instanceof WriteStream))
          return new WriteStream(path2, options);
        Stream.call(this);
        this.path = path2;
        this.fd = null;
        this.writable = true;
        this.flags = "w";
        this.encoding = "binary";
        this.mode = 438;
        this.bytesWritten = 0;
        options = options || {};
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.start !== void 0) {
          if (typeof this.start !== "number") {
            throw TypeError("start must be a Number");
          }
          if (this.start < 0) {
            throw new Error("start must be >= zero");
          }
          this.pos = this.start;
        }
        this.busy = false;
        this._queue = [];
        if (this.fd === null) {
          this._open = fs3.open;
          this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
          this.flush();
        }
      }
    }
  }
});

// node_modules/graceful-fs/clone.js
var require_clone = __commonJS({
  "node_modules/graceful-fs/clone.js"(exports, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = clone;
    var getPrototypeOf = Object.getPrototypeOf || function(obj) {
      return obj.__proto__;
    };
    function clone(obj) {
      if (obj === null || typeof obj !== "object")
        return obj;
      if (obj instanceof Object)
        var copy = { __proto__: getPrototypeOf(obj) };
      else
        var copy = /* @__PURE__ */ Object.create(null);
      Object.getOwnPropertyNames(obj).forEach(function(key) {
        Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
      });
      return copy;
    }
  }
});

// node_modules/graceful-fs/graceful-fs.js
var require_graceful_fs = __commonJS({
  "node_modules/graceful-fs/graceful-fs.js"(exports, module2) {
    init_cjs_shims();
    var fs3 = require("fs");
    var polyfills = require_polyfills();
    var legacy = require_legacy_streams();
    var clone = require_clone();
    var util = require("util");
    var gracefulQueue;
    var previousSymbol;
    if (typeof Symbol === "function" && typeof Symbol.for === "function") {
      gracefulQueue = Symbol.for("graceful-fs.queue");
      previousSymbol = Symbol.for("graceful-fs.previous");
    } else {
      gracefulQueue = "___graceful-fs.queue";
      previousSymbol = "___graceful-fs.previous";
    }
    function noop() {
    }
    function publishQueue(context, queue2) {
      Object.defineProperty(context, gracefulQueue, {
        get: function() {
          return queue2;
        }
      });
    }
    var debug = noop;
    if (util.debuglog)
      debug = util.debuglog("gfs4");
    else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
      debug = function() {
        var m = util.format.apply(util, arguments);
        m = "GFS4: " + m.split(/\n/).join("\nGFS4: ");
        console.error(m);
      };
    if (!fs3[gracefulQueue]) {
      queue = global[gracefulQueue] || [];
      publishQueue(fs3, queue);
      fs3.close = function(fs$close) {
        function close(fd, cb) {
          return fs$close.call(fs3, fd, function(err) {
            if (!err) {
              resetQueue();
            }
            if (typeof cb === "function")
              cb.apply(this, arguments);
          });
        }
        Object.defineProperty(close, previousSymbol, {
          value: fs$close
        });
        return close;
      }(fs3.close);
      fs3.closeSync = function(fs$closeSync) {
        function closeSync(fd) {
          fs$closeSync.apply(fs3, arguments);
          resetQueue();
        }
        Object.defineProperty(closeSync, previousSymbol, {
          value: fs$closeSync
        });
        return closeSync;
      }(fs3.closeSync);
      if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
        process.on("exit", function() {
          debug(fs3[gracefulQueue]);
          require("assert").equal(fs3[gracefulQueue].length, 0);
        });
      }
    }
    var queue;
    if (!global[gracefulQueue]) {
      publishQueue(global, fs3[gracefulQueue]);
    }
    module2.exports = patch(clone(fs3));
    if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs3.__patched) {
      module2.exports = patch(fs3);
      fs3.__patched = true;
    }
    function patch(fs4) {
      polyfills(fs4);
      fs4.gracefulify = patch;
      fs4.createReadStream = createReadStream;
      fs4.createWriteStream = createWriteStream;
      var fs$readFile = fs4.readFile;
      fs4.readFile = readFile;
      function readFile(path2, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$readFile(path2, options, cb);
        function go$readFile(path3, options2, cb2, startTime) {
          return fs$readFile(path3, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$readFile, [path3, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$writeFile = fs4.writeFile;
      fs4.writeFile = writeFile;
      function writeFile(path2, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$writeFile(path2, data, options, cb);
        function go$writeFile(path3, data2, options2, cb2, startTime) {
          return fs$writeFile(path3, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$writeFile, [path3, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$appendFile = fs4.appendFile;
      if (fs$appendFile)
        fs4.appendFile = appendFile;
      function appendFile(path2, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$appendFile(path2, data, options, cb);
        function go$appendFile(path3, data2, options2, cb2, startTime) {
          return fs$appendFile(path3, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$appendFile, [path3, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$copyFile = fs4.copyFile;
      if (fs$copyFile)
        fs4.copyFile = copyFile;
      function copyFile(src, dest, flags, cb) {
        if (typeof flags === "function") {
          cb = flags;
          flags = 0;
        }
        return go$copyFile(src, dest, flags, cb);
        function go$copyFile(src2, dest2, flags2, cb2, startTime) {
          return fs$copyFile(src2, dest2, flags2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$copyFile, [src2, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$readdir = fs4.readdir;
      fs4.readdir = readdir;
      function readdir(path2, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$readdir(path2, options, cb);
        function go$readdir(path3, options2, cb2, startTime) {
          return fs$readdir(path3, options2, function(err, files) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$readdir, [path3, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (files && files.sort)
                files.sort();
              if (typeof cb2 === "function")
                cb2.call(this, err, files);
            }
          });
        }
      }
      if (process.version.substr(0, 4) === "v0.8") {
        var legStreams = legacy(fs4);
        ReadStream = legStreams.ReadStream;
        WriteStream = legStreams.WriteStream;
      }
      var fs$ReadStream = fs4.ReadStream;
      if (fs$ReadStream) {
        ReadStream.prototype = Object.create(fs$ReadStream.prototype);
        ReadStream.prototype.open = ReadStream$open;
      }
      var fs$WriteStream = fs4.WriteStream;
      if (fs$WriteStream) {
        WriteStream.prototype = Object.create(fs$WriteStream.prototype);
        WriteStream.prototype.open = WriteStream$open;
      }
      Object.defineProperty(fs4, "ReadStream", {
        get: function() {
          return ReadStream;
        },
        set: function(val) {
          ReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(fs4, "WriteStream", {
        get: function() {
          return WriteStream;
        },
        set: function(val) {
          WriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileReadStream = ReadStream;
      Object.defineProperty(fs4, "FileReadStream", {
        get: function() {
          return FileReadStream;
        },
        set: function(val) {
          FileReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileWriteStream = WriteStream;
      Object.defineProperty(fs4, "FileWriteStream", {
        get: function() {
          return FileWriteStream;
        },
        set: function(val) {
          FileWriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      function ReadStream(path2, options) {
        if (this instanceof ReadStream)
          return fs$ReadStream.apply(this, arguments), this;
        else
          return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
      }
      function ReadStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            if (that.autoClose)
              that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
            that.read();
          }
        });
      }
      function WriteStream(path2, options) {
        if (this instanceof WriteStream)
          return fs$WriteStream.apply(this, arguments), this;
        else
          return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
      }
      function WriteStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
          }
        });
      }
      function createReadStream(path2, options) {
        return new fs4.ReadStream(path2, options);
      }
      function createWriteStream(path2, options) {
        return new fs4.WriteStream(path2, options);
      }
      var fs$open = fs4.open;
      fs4.open = open;
      function open(path2, flags, mode, cb) {
        if (typeof mode === "function")
          cb = mode, mode = null;
        return go$open(path2, flags, mode, cb);
        function go$open(path3, flags2, mode2, cb2, startTime) {
          return fs$open(path3, flags2, mode2, function(err, fd) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$open, [path3, flags2, mode2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      return fs4;
    }
    function enqueue(elem) {
      debug("ENQUEUE", elem[0].name, elem[1]);
      fs3[gracefulQueue].push(elem);
      retry();
    }
    var retryTimer;
    function resetQueue() {
      var now = Date.now();
      for (var i = 0; i < fs3[gracefulQueue].length; ++i) {
        if (fs3[gracefulQueue][i].length > 2) {
          fs3[gracefulQueue][i][3] = now;
          fs3[gracefulQueue][i][4] = now;
        }
      }
      retry();
    }
    function retry() {
      clearTimeout(retryTimer);
      retryTimer = void 0;
      if (fs3[gracefulQueue].length === 0)
        return;
      var elem = fs3[gracefulQueue].shift();
      var fn = elem[0];
      var args = elem[1];
      var err = elem[2];
      var startTime = elem[3];
      var lastTime = elem[4];
      if (startTime === void 0) {
        debug("RETRY", fn.name, args);
        fn.apply(null, args);
      } else if (Date.now() - startTime >= 6e4) {
        debug("TIMEOUT", fn.name, args);
        var cb = args.pop();
        if (typeof cb === "function")
          cb.call(null, err);
      } else {
        var sinceAttempt = Date.now() - lastTime;
        var sinceStart = Math.max(lastTime - startTime, 1);
        var desiredDelay = Math.min(sinceStart * 1.2, 100);
        if (sinceAttempt >= desiredDelay) {
          debug("RETRY", fn.name, args);
          fn.apply(null, args.concat([startTime]));
        } else {
          fs3[gracefulQueue].push(elem);
        }
      }
      if (retryTimer === void 0) {
        retryTimer = setTimeout(retry, 0);
      }
    }
  }
});

// node_modules/fs.realpath/old.js
var require_old = __commonJS({
  "node_modules/fs.realpath/old.js"(exports) {
    init_cjs_shims();
    var pathModule = require("path");
    var isWindows = process.platform === "win32";
    var fs3 = require("fs");
    var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);
    function rethrow() {
      var callback;
      if (DEBUG) {
        var backtrace = new Error();
        callback = debugCallback;
      } else
        callback = missingCallback;
      return callback;
      function debugCallback(err) {
        if (err) {
          backtrace.message = err.message;
          err = backtrace;
          missingCallback(err);
        }
      }
      function missingCallback(err) {
        if (err) {
          if (process.throwDeprecation)
            throw err;
          else if (!process.noDeprecation) {
            var msg = "fs: missing callback " + (err.stack || err.message);
            if (process.traceDeprecation)
              console.trace(msg);
            else
              console.error(msg);
          }
        }
      }
    }
    function maybeCallback(cb) {
      return typeof cb === "function" ? cb : rethrow();
    }
    var normalize = pathModule.normalize;
    if (isWindows) {
      nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
    } else {
      nextPartRe = /(.*?)(?:[\/]+|$)/g;
    }
    var nextPartRe;
    if (isWindows) {
      splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
    } else {
      splitRootRe = /^[\/]*/;
    }
    var splitRootRe;
    exports.realpathSync = function realpathSync(p, cache) {
      p = pathModule.resolve(p);
      if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
        return cache[p];
      }
      var original = p, seenLinks = {}, knownHard = {};
      var pos;
      var current;
      var base;
      var previous;
      start();
      function start() {
        var m = splitRootRe.exec(p);
        pos = m[0].length;
        current = m[0];
        base = m[0];
        previous = "";
        if (isWindows && !knownHard[base]) {
          fs3.lstatSync(base);
          knownHard[base] = true;
        }
      }
      while (pos < p.length) {
        nextPartRe.lastIndex = pos;
        var result = nextPartRe.exec(p);
        previous = current;
        current += result[0];
        base = previous + result[1];
        pos = nextPartRe.lastIndex;
        if (knownHard[base] || cache && cache[base] === base) {
          continue;
        }
        var resolvedLink;
        if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
          resolvedLink = cache[base];
        } else {
          var stat = fs3.lstatSync(base);
          if (!stat.isSymbolicLink()) {
            knownHard[base] = true;
            if (cache)
              cache[base] = base;
            continue;
          }
          var linkTarget = null;
          if (!isWindows) {
            var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
            if (seenLinks.hasOwnProperty(id)) {
              linkTarget = seenLinks[id];
            }
          }
          if (linkTarget === null) {
            fs3.statSync(base);
            linkTarget = fs3.readlinkSync(base);
          }
          resolvedLink = pathModule.resolve(previous, linkTarget);
          if (cache)
            cache[base] = resolvedLink;
          if (!isWindows)
            seenLinks[id] = linkTarget;
        }
        p = pathModule.resolve(resolvedLink, p.slice(pos));
        start();
      }
      if (cache)
        cache[original] = p;
      return p;
    };
    exports.realpath = function realpath(p, cache, cb) {
      if (typeof cb !== "function") {
        cb = maybeCallback(cache);
        cache = null;
      }
      p = pathModule.resolve(p);
      if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
        return process.nextTick(cb.bind(null, null, cache[p]));
      }
      var original = p, seenLinks = {}, knownHard = {};
      var pos;
      var current;
      var base;
      var previous;
      start();
      function start() {
        var m = splitRootRe.exec(p);
        pos = m[0].length;
        current = m[0];
        base = m[0];
        previous = "";
        if (isWindows && !knownHard[base]) {
          fs3.lstat(base, function(err) {
            if (err)
              return cb(err);
            knownHard[base] = true;
            LOOP();
          });
        } else {
          process.nextTick(LOOP);
        }
      }
      function LOOP() {
        if (pos >= p.length) {
          if (cache)
            cache[original] = p;
          return cb(null, p);
        }
        nextPartRe.lastIndex = pos;
        var result = nextPartRe.exec(p);
        previous = current;
        current += result[0];
        base = previous + result[1];
        pos = nextPartRe.lastIndex;
        if (knownHard[base] || cache && cache[base] === base) {
          return process.nextTick(LOOP);
        }
        if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
          return gotResolvedLink(cache[base]);
        }
        return fs3.lstat(base, gotStat);
      }
      function gotStat(err, stat) {
        if (err)
          return cb(err);
        if (!stat.isSymbolicLink()) {
          knownHard[base] = true;
          if (cache)
            cache[base] = base;
          return process.nextTick(LOOP);
        }
        if (!isWindows) {
          var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
          if (seenLinks.hasOwnProperty(id)) {
            return gotTarget(null, seenLinks[id], base);
          }
        }
        fs3.stat(base, function(err2) {
          if (err2)
            return cb(err2);
          fs3.readlink(base, function(err3, target) {
            if (!isWindows)
              seenLinks[id] = target;
            gotTarget(err3, target);
          });
        });
      }
      function gotTarget(err, target, base2) {
        if (err)
          return cb(err);
        var resolvedLink = pathModule.resolve(previous, target);
        if (cache)
          cache[base2] = resolvedLink;
        gotResolvedLink(resolvedLink);
      }
      function gotResolvedLink(resolvedLink) {
        p = pathModule.resolve(resolvedLink, p.slice(pos));
        start();
      }
    };
  }
});

// node_modules/fs.realpath/index.js
var require_fs = __commonJS({
  "node_modules/fs.realpath/index.js"(exports, module2) {
    init_cjs_shims();
    module2.exports = realpath;
    realpath.realpath = realpath;
    realpath.sync = realpathSync;
    realpath.realpathSync = realpathSync;
    realpath.monkeypatch = monkeypatch;
    realpath.unmonkeypatch = unmonkeypatch;
    var fs3 = require("fs");
    var origRealpath = fs3.realpath;
    var origRealpathSync = fs3.realpathSync;
    var version = process.version;
    var ok = /^v[0-5]\./.test(version);
    var old = require_old();
    function newError(er) {
      return er && er.syscall === "realpath" && (er.code === "ELOOP" || er.code === "ENOMEM" || er.code === "ENAMETOOLONG");
    }
    function realpath(p, cache, cb) {
      if (ok) {
        return origRealpath(p, cache, cb);
      }
      if (typeof cache === "function") {
        cb = cache;
        cache = null;
      }
      origRealpath(p, cache, function(er, result) {
        if (newError(er)) {
          old.realpath(p, cache, cb);
        } else {
          cb(er, result);
        }
      });
    }
    function realpathSync(p, cache) {
      if (ok) {
        return origRealpathSync(p, cache);
      }
      try {
        return origRealpathSync(p, cache);
      } catch (er) {
        if (newError(er)) {
          return old.realpathSync(p, cache);
        } else {
          throw er;
        }
      }
    }
    function monkeypatch() {
      fs3.realpath = realpath;
      fs3.realpathSync = realpathSync;
    }
    function unmonkeypatch() {
      fs3.realpath = origRealpath;
      fs3.realpathSync = origRealpathSync;
    }
  }
});

// node_modules/concat-map/index.js
var require_concat_map = __commonJS({
  "node_modules/concat-map/index.js"(exports, module2) {
    init_cjs_shims();
    module2.exports = function(xs, fn) {
      var res = [];
      for (var i = 0; i < xs.length; i++) {
        var x = fn(xs[i], i);
        if (isArray(x))
          res.push.apply(res, x);
        else
          res.push(x);
      }
      return res;
    };
    var isArray = Array.isArray || function(xs) {
      return Object.prototype.toString.call(xs) === "[object Array]";
    };
  }
});

// node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
  "node_modules/balanced-match/index.js"(exports, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = balanced;
    function balanced(a, b, str) {
      if (a instanceof RegExp)
        a = maybeMatch(a, str);
      if (b instanceof RegExp)
        b = maybeMatch(b, str);
      var r = range(a, b, str);
      return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + a.length, r[1]),
        post: str.slice(r[1] + b.length)
      };
    }
    function maybeMatch(reg, str) {
      var m = str.match(reg);
      return m ? m[0] : null;
    }
    balanced.range = range;
    function range(a, b, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a);
      var bi = str.indexOf(b, ai + 1);
      var i = ai;
      if (ai >= 0 && bi > 0) {
        if (a === b) {
          return [ai, bi];
        }
        begs = [];
        left = str.length;
        while (i >= 0 && !result) {
          if (i == ai) {
            begs.push(i);
            ai = str.indexOf(a, i + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b, i + 1);
          }
          i = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  }
});

// node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS({
  "node_modules/brace-expansion/index.js"(exports, module2) {
    init_cjs_shims();
    var concatMap = require_concat_map();
    var balanced = require_balanced_match();
    module2.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m = balanced("{", "}", str);
      if (!m)
        return str.split(",");
      var pre = m.pre;
      var body = m.body;
      var post = m.post;
      var p = pre.split(",");
      p[p.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
      }
      parts.push.apply(parts, p);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i, y) {
      return i <= y;
    }
    function gte(i, y) {
      return i >= y;
    }
    function expand(str, isTop) {
      var expansions = [];
      var m = balanced("{", "}", str);
      if (!m || /\$$/.test(m.pre))
        return [str];
      var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
      var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
      var isSequence = isNumericSequence || isAlphaSequence;
      var isOptions = m.body.indexOf(",") >= 0;
      if (!isSequence && !isOptions) {
        if (m.post.match(/,.*\}/)) {
          str = m.pre + "{" + m.body + escClose + m.post;
          return expand(str);
        }
        return [str];
      }
      var n;
      if (isSequence) {
        n = m.body.split(/\.\./);
      } else {
        n = parseCommaParts(m.body);
        if (n.length === 1) {
          n = expand(n[0], false).map(embrace);
          if (n.length === 1) {
            var post = m.post.length ? expand(m.post, false) : [""];
            return post.map(function(p) {
              return m.pre + n[0] + p;
            });
          }
        }
      }
      var pre = m.pre;
      var post = m.post.length ? expand(m.post, false) : [""];
      var N;
      if (isSequence) {
        var x = numeric(n[0]);
        var y = numeric(n[1]);
        var width = Math.max(n[0].length, n[1].length);
        var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
        var test = lte;
        var reverse = y < x;
        if (reverse) {
          incr *= -1;
          test = gte;
        }
        var pad = n.some(isPadded);
        N = [];
        for (var i = x; test(i, y); i += incr) {
          var c;
          if (isAlphaSequence) {
            c = String.fromCharCode(i);
            if (c === "\\")
              c = "";
          } else {
            c = String(i);
            if (pad) {
              var need = width - c.length;
              if (need > 0) {
                var z = new Array(need + 1).join("0");
                if (i < 0)
                  c = "-" + z + c.slice(1);
                else
                  c = z + c;
              }
            }
          }
          N.push(c);
        }
      } else {
        N = concatMap(n, function(el) {
          return expand(el, false);
        });
      }
      for (var j = 0; j < N.length; j++) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + N[j] + post[k];
          if (!isTop || isSequence || expansion)
            expansions.push(expansion);
        }
      }
      return expansions;
    }
  }
});

// node_modules/minimatch/minimatch.js
var require_minimatch = __commonJS({
  "node_modules/minimatch/minimatch.js"(exports, module2) {
    init_cjs_shims();
    module2.exports = minimatch;
    minimatch.Minimatch = Minimatch;
    var path2 = { sep: "/" };
    try {
      path2 = require("path");
    } catch (er) {
    }
    var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
    var expand = require_brace_expansion();
    var plTypes = {
      "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
      "?": { open: "(?:", close: ")?" },
      "+": { open: "(?:", close: ")+" },
      "*": { open: "(?:", close: ")*" },
      "@": { open: "(?:", close: ")" }
    };
    var qmark = "[^/]";
    var star = qmark + "*?";
    var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    var reSpecials = charSet("().*{}+?[]^$\\!");
    function charSet(s) {
      return s.split("").reduce(function(set, c) {
        set[c] = true;
        return set;
      }, {});
    }
    var slashSplit = /\/+/;
    minimatch.filter = filter;
    function filter(pattern, options) {
      options = options || {};
      return function(p, i, list) {
        return minimatch(p, pattern, options);
      };
    }
    function ext(a, b) {
      a = a || {};
      b = b || {};
      var t = {};
      Object.keys(b).forEach(function(k) {
        t[k] = b[k];
      });
      Object.keys(a).forEach(function(k) {
        t[k] = a[k];
      });
      return t;
    }
    minimatch.defaults = function(def) {
      if (!def || !Object.keys(def).length)
        return minimatch;
      var orig = minimatch;
      var m = function minimatch2(p, pattern, options) {
        return orig.minimatch(p, pattern, ext(def, options));
      };
      m.Minimatch = function Minimatch2(pattern, options) {
        return new orig.Minimatch(pattern, ext(def, options));
      };
      return m;
    };
    Minimatch.defaults = function(def) {
      if (!def || !Object.keys(def).length)
        return Minimatch;
      return minimatch.defaults(def).Minimatch;
    };
    function minimatch(p, pattern, options) {
      if (typeof pattern !== "string") {
        throw new TypeError("glob pattern string required");
      }
      if (!options)
        options = {};
      if (!options.nocomment && pattern.charAt(0) === "#") {
        return false;
      }
      if (pattern.trim() === "")
        return p === "";
      return new Minimatch(pattern, options).match(p);
    }
    function Minimatch(pattern, options) {
      if (!(this instanceof Minimatch)) {
        return new Minimatch(pattern, options);
      }
      if (typeof pattern !== "string") {
        throw new TypeError("glob pattern string required");
      }
      if (!options)
        options = {};
      pattern = pattern.trim();
      if (path2.sep !== "/") {
        pattern = pattern.split(path2.sep).join("/");
      }
      this.options = options;
      this.set = [];
      this.pattern = pattern;
      this.regexp = null;
      this.negate = false;
      this.comment = false;
      this.empty = false;
      this.make();
    }
    Minimatch.prototype.debug = function() {
    };
    Minimatch.prototype.make = make;
    function make() {
      if (this._made)
        return;
      var pattern = this.pattern;
      var options = this.options;
      if (!options.nocomment && pattern.charAt(0) === "#") {
        this.comment = true;
        return;
      }
      if (!pattern) {
        this.empty = true;
        return;
      }
      this.parseNegate();
      var set = this.globSet = this.braceExpand();
      if (options.debug)
        this.debug = console.error;
      this.debug(this.pattern, set);
      set = this.globParts = set.map(function(s) {
        return s.split(slashSplit);
      });
      this.debug(this.pattern, set);
      set = set.map(function(s, si, set2) {
        return s.map(this.parse, this);
      }, this);
      this.debug(this.pattern, set);
      set = set.filter(function(s) {
        return s.indexOf(false) === -1;
      });
      this.debug(this.pattern, set);
      this.set = set;
    }
    Minimatch.prototype.parseNegate = parseNegate;
    function parseNegate() {
      var pattern = this.pattern;
      var negate = false;
      var options = this.options;
      var negateOffset = 0;
      if (options.nonegate)
        return;
      for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === "!"; i++) {
        negate = !negate;
        negateOffset++;
      }
      if (negateOffset)
        this.pattern = pattern.substr(negateOffset);
      this.negate = negate;
    }
    minimatch.braceExpand = function(pattern, options) {
      return braceExpand(pattern, options);
    };
    Minimatch.prototype.braceExpand = braceExpand;
    function braceExpand(pattern, options) {
      if (!options) {
        if (this instanceof Minimatch) {
          options = this.options;
        } else {
          options = {};
        }
      }
      pattern = typeof pattern === "undefined" ? this.pattern : pattern;
      if (typeof pattern === "undefined") {
        throw new TypeError("undefined pattern");
      }
      if (options.nobrace || !pattern.match(/\{.*\}/)) {
        return [pattern];
      }
      return expand(pattern);
    }
    Minimatch.prototype.parse = parse2;
    var SUBPARSE = {};
    function parse2(pattern, isSub) {
      if (pattern.length > 1024 * 64) {
        throw new TypeError("pattern is too long");
      }
      var options = this.options;
      if (!options.noglobstar && pattern === "**")
        return GLOBSTAR;
      if (pattern === "")
        return "";
      var re = "";
      var hasMagic = !!options.nocase;
      var escaping = false;
      var patternListStack = [];
      var negativeLists = [];
      var stateChar;
      var inClass = false;
      var reClassStart = -1;
      var classStart = -1;
      var patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
      var self = this;
      function clearStateChar() {
        if (stateChar) {
          switch (stateChar) {
            case "*":
              re += star;
              hasMagic = true;
              break;
            case "?":
              re += qmark;
              hasMagic = true;
              break;
            default:
              re += "\\" + stateChar;
              break;
          }
          self.debug("clearStateChar %j %j", stateChar, re);
          stateChar = false;
        }
      }
      for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
        this.debug("%s	%s %s %j", pattern, i, re, c);
        if (escaping && reSpecials[c]) {
          re += "\\" + c;
          escaping = false;
          continue;
        }
        switch (c) {
          case "/":
            return false;
          case "\\":
            clearStateChar();
            escaping = true;
            continue;
          case "?":
          case "*":
          case "+":
          case "@":
          case "!":
            this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
            if (inClass) {
              this.debug("  in class");
              if (c === "!" && i === classStart + 1)
                c = "^";
              re += c;
              continue;
            }
            self.debug("call clearStateChar %j", stateChar);
            clearStateChar();
            stateChar = c;
            if (options.noext)
              clearStateChar();
            continue;
          case "(":
            if (inClass) {
              re += "(";
              continue;
            }
            if (!stateChar) {
              re += "\\(";
              continue;
            }
            patternListStack.push({
              type: stateChar,
              start: i - 1,
              reStart: re.length,
              open: plTypes[stateChar].open,
              close: plTypes[stateChar].close
            });
            re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
            this.debug("plType %j %j", stateChar, re);
            stateChar = false;
            continue;
          case ")":
            if (inClass || !patternListStack.length) {
              re += "\\)";
              continue;
            }
            clearStateChar();
            hasMagic = true;
            var pl = patternListStack.pop();
            re += pl.close;
            if (pl.type === "!") {
              negativeLists.push(pl);
            }
            pl.reEnd = re.length;
            continue;
          case "|":
            if (inClass || !patternListStack.length || escaping) {
              re += "\\|";
              escaping = false;
              continue;
            }
            clearStateChar();
            re += "|";
            continue;
          case "[":
            clearStateChar();
            if (inClass) {
              re += "\\" + c;
              continue;
            }
            inClass = true;
            classStart = i;
            reClassStart = re.length;
            re += c;
            continue;
          case "]":
            if (i === classStart + 1 || !inClass) {
              re += "\\" + c;
              escaping = false;
              continue;
            }
            if (inClass) {
              var cs = pattern.substring(classStart + 1, i);
              try {
                RegExp("[" + cs + "]");
              } catch (er) {
                var sp = this.parse(cs, SUBPARSE);
                re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
                hasMagic = hasMagic || sp[1];
                inClass = false;
                continue;
              }
            }
            hasMagic = true;
            inClass = false;
            re += c;
            continue;
          default:
            clearStateChar();
            if (escaping) {
              escaping = false;
            } else if (reSpecials[c] && !(c === "^" && inClass)) {
              re += "\\";
            }
            re += c;
        }
      }
      if (inClass) {
        cs = pattern.substr(classStart + 1);
        sp = this.parse(cs, SUBPARSE);
        re = re.substr(0, reClassStart) + "\\[" + sp[0];
        hasMagic = hasMagic || sp[1];
      }
      for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
        var tail = re.slice(pl.reStart + pl.open.length);
        this.debug("setting tail", re, pl);
        tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_, $1, $2) {
          if (!$2) {
            $2 = "\\";
          }
          return $1 + $1 + $2 + "|";
        });
        this.debug("tail=%j\n   %s", tail, tail, pl, re);
        var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
        hasMagic = true;
        re = re.slice(0, pl.reStart) + t + "\\(" + tail;
      }
      clearStateChar();
      if (escaping) {
        re += "\\\\";
      }
      var addPatternStart = false;
      switch (re.charAt(0)) {
        case ".":
        case "[":
        case "(":
          addPatternStart = true;
      }
      for (var n = negativeLists.length - 1; n > -1; n--) {
        var nl = negativeLists[n];
        var nlBefore = re.slice(0, nl.reStart);
        var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
        var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
        var nlAfter = re.slice(nl.reEnd);
        nlLast += nlAfter;
        var openParensBefore = nlBefore.split("(").length - 1;
        var cleanAfter = nlAfter;
        for (i = 0; i < openParensBefore; i++) {
          cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
        }
        nlAfter = cleanAfter;
        var dollar = "";
        if (nlAfter === "" && isSub !== SUBPARSE) {
          dollar = "$";
        }
        var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
        re = newRe;
      }
      if (re !== "" && hasMagic) {
        re = "(?=.)" + re;
      }
      if (addPatternStart) {
        re = patternStart + re;
      }
      if (isSub === SUBPARSE) {
        return [re, hasMagic];
      }
      if (!hasMagic) {
        return globUnescape(pattern);
      }
      var flags = options.nocase ? "i" : "";
      try {
        var regExp = new RegExp("^" + re + "$", flags);
      } catch (er) {
        return new RegExp("$.");
      }
      regExp._glob = pattern;
      regExp._src = re;
      return regExp;
    }
    minimatch.makeRe = function(pattern, options) {
      return new Minimatch(pattern, options || {}).makeRe();
    };
    Minimatch.prototype.makeRe = makeRe;
    function makeRe() {
      if (this.regexp || this.regexp === false)
        return this.regexp;
      var set = this.set;
      if (!set.length) {
        this.regexp = false;
        return this.regexp;
      }
      var options = this.options;
      var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
      var flags = options.nocase ? "i" : "";
      var re = set.map(function(pattern) {
        return pattern.map(function(p) {
          return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
        }).join("\\/");
      }).join("|");
      re = "^(?:" + re + ")$";
      if (this.negate)
        re = "^(?!" + re + ").*$";
      try {
        this.regexp = new RegExp(re, flags);
      } catch (ex) {
        this.regexp = false;
      }
      return this.regexp;
    }
    minimatch.match = function(list, pattern, options) {
      options = options || {};
      var mm = new Minimatch(pattern, options);
      list = list.filter(function(f) {
        return mm.match(f);
      });
      if (mm.options.nonull && !list.length) {
        list.push(pattern);
      }
      return list;
    };
    Minimatch.prototype.match = match;
    function match(f, partial) {
      this.debug("match", f, this.pattern);
      if (this.comment)
        return false;
      if (this.empty)
        return f === "";
      if (f === "/" && partial)
        return true;
      var options = this.options;
      if (path2.sep !== "/") {
        f = f.split(path2.sep).join("/");
      }
      f = f.split(slashSplit);
      this.debug(this.pattern, "split", f);
      var set = this.set;
      this.debug(this.pattern, "set", set);
      var filename;
      var i;
      for (i = f.length - 1; i >= 0; i--) {
        filename = f[i];
        if (filename)
          break;
      }
      for (i = 0; i < set.length; i++) {
        var pattern = set[i];
        var file = f;
        if (options.matchBase && pattern.length === 1) {
          file = [filename];
        }
        var hit = this.matchOne(file, pattern, partial);
        if (hit) {
          if (options.flipNegate)
            return true;
          return !this.negate;
        }
      }
      if (options.flipNegate)
        return false;
      return this.negate;
    }
    Minimatch.prototype.matchOne = function(file, pattern, partial) {
      var options = this.options;
      this.debug("matchOne", { "this": this, file, pattern });
      this.debug("matchOne", file.length, pattern.length);
      for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
        this.debug("matchOne loop");
        var p = pattern[pi];
        var f = file[fi];
        this.debug(pattern, p, f);
        if (p === false)
          return false;
        if (p === GLOBSTAR) {
          this.debug("GLOBSTAR", [pattern, p, f]);
          var fr = fi;
          var pr = pi + 1;
          if (pr === pl) {
            this.debug("** at the end");
            for (; fi < fl; fi++) {
              if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                return false;
            }
            return true;
          }
          while (fr < fl) {
            var swallowee = file[fr];
            this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
            if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
              this.debug("globstar found match!", fr, fl, swallowee);
              return true;
            } else {
              if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                this.debug("dot detected!", file, fr, pattern, pr);
                break;
              }
              this.debug("globstar swallow a segment, and continue");
              fr++;
            }
          }
          if (partial) {
            this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
            if (fr === fl)
              return true;
          }
          return false;
        }
        var hit;
        if (typeof p === "string") {
          if (options.nocase) {
            hit = f.toLowerCase() === p.toLowerCase();
          } else {
            hit = f === p;
          }
          this.debug("string match", p, f, hit);
        } else {
          hit = f.match(p);
          this.debug("pattern match", p, f, hit);
        }
        if (!hit)
          return false;
      }
      if (fi === fl && pi === pl) {
        return true;
      } else if (fi === fl) {
        return partial;
      } else if (pi === pl) {
        var emptyFileEnd = fi === fl - 1 && file[fi] === "";
        return emptyFileEnd;
      }
      throw new Error("wtf?");
    };
    function globUnescape(s) {
      return s.replace(/\\(.)/g, "$1");
    }
    function regExpEscape(s) {
      return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    }
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports, module2) {
    init_cjs_shims();
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/inherits/inherits.js
var require_inherits = __commonJS({
  "node_modules/inherits/inherits.js"(exports, module2) {
    init_cjs_shims();
    try {
      util = require("util");
      if (typeof util.inherits !== "function")
        throw "";
      module2.exports = util.inherits;
    } catch (e) {
      module2.exports = require_inherits_browser();
    }
    var util;
  }
});

// node_modules/path-is-absolute/index.js
var require_path_is_absolute = __commonJS({
  "node_modules/path-is-absolute/index.js"(exports, module2) {
    "use strict";
    init_cjs_shims();
    function posix(path2) {
      return path2.charAt(0) === "/";
    }
    function win32(path2) {
      var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
      var result = splitDeviceRe.exec(path2);
      var device = result[1] || "";
      var isUnc = Boolean(device && device.charAt(1) !== ":");
      return Boolean(result[2] || isUnc);
    }
    module2.exports = process.platform === "win32" ? win32 : posix;
    module2.exports.posix = posix;
    module2.exports.win32 = win32;
  }
});

// node_modules/glob/common.js
var require_common = __commonJS({
  "node_modules/glob/common.js"(exports) {
    init_cjs_shims();
    exports.setopts = setopts;
    exports.ownProp = ownProp;
    exports.makeAbs = makeAbs;
    exports.finish = finish;
    exports.mark = mark;
    exports.isIgnored = isIgnored;
    exports.childrenIgnored = childrenIgnored;
    function ownProp(obj, field) {
      return Object.prototype.hasOwnProperty.call(obj, field);
    }
    var path2 = require("path");
    var minimatch = require_minimatch();
    var isAbsolute = require_path_is_absolute();
    var Minimatch = minimatch.Minimatch;
    function alphasort(a, b) {
      return a.localeCompare(b, "en");
    }
    function setupIgnores(self, options) {
      self.ignore = options.ignore || [];
      if (!Array.isArray(self.ignore))
        self.ignore = [self.ignore];
      if (self.ignore.length) {
        self.ignore = self.ignore.map(ignoreMap);
      }
    }
    function ignoreMap(pattern) {
      var gmatcher = null;
      if (pattern.slice(-3) === "/**") {
        var gpattern = pattern.replace(/(\/\*\*)+$/, "");
        gmatcher = new Minimatch(gpattern, { dot: true });
      }
      return {
        matcher: new Minimatch(pattern, { dot: true }),
        gmatcher
      };
    }
    function setopts(self, pattern, options) {
      if (!options)
        options = {};
      if (options.matchBase && pattern.indexOf("/") === -1) {
        if (options.noglobstar) {
          throw new Error("base matching requires globstar");
        }
        pattern = "**/" + pattern;
      }
      self.silent = !!options.silent;
      self.pattern = pattern;
      self.strict = options.strict !== false;
      self.realpath = !!options.realpath;
      self.realpathCache = options.realpathCache || /* @__PURE__ */ Object.create(null);
      self.follow = !!options.follow;
      self.dot = !!options.dot;
      self.mark = !!options.mark;
      self.nodir = !!options.nodir;
      if (self.nodir)
        self.mark = true;
      self.sync = !!options.sync;
      self.nounique = !!options.nounique;
      self.nonull = !!options.nonull;
      self.nosort = !!options.nosort;
      self.nocase = !!options.nocase;
      self.stat = !!options.stat;
      self.noprocess = !!options.noprocess;
      self.absolute = !!options.absolute;
      self.maxLength = options.maxLength || Infinity;
      self.cache = options.cache || /* @__PURE__ */ Object.create(null);
      self.statCache = options.statCache || /* @__PURE__ */ Object.create(null);
      self.symlinks = options.symlinks || /* @__PURE__ */ Object.create(null);
      setupIgnores(self, options);
      self.changedCwd = false;
      var cwd = process.cwd();
      if (!ownProp(options, "cwd"))
        self.cwd = cwd;
      else {
        self.cwd = path2.resolve(options.cwd);
        self.changedCwd = self.cwd !== cwd;
      }
      self.root = options.root || path2.resolve(self.cwd, "/");
      self.root = path2.resolve(self.root);
      if (process.platform === "win32")
        self.root = self.root.replace(/\\/g, "/");
      self.cwdAbs = isAbsolute(self.cwd) ? self.cwd : makeAbs(self, self.cwd);
      if (process.platform === "win32")
        self.cwdAbs = self.cwdAbs.replace(/\\/g, "/");
      self.nomount = !!options.nomount;
      options.nonegate = true;
      options.nocomment = true;
      self.minimatch = new Minimatch(pattern, options);
      self.options = self.minimatch.options;
    }
    function finish(self) {
      var nou = self.nounique;
      var all = nou ? [] : /* @__PURE__ */ Object.create(null);
      for (var i = 0, l = self.matches.length; i < l; i++) {
        var matches = self.matches[i];
        if (!matches || Object.keys(matches).length === 0) {
          if (self.nonull) {
            var literal = self.minimatch.globSet[i];
            if (nou)
              all.push(literal);
            else
              all[literal] = true;
          }
        } else {
          var m = Object.keys(matches);
          if (nou)
            all.push.apply(all, m);
          else
            m.forEach(function(m2) {
              all[m2] = true;
            });
        }
      }
      if (!nou)
        all = Object.keys(all);
      if (!self.nosort)
        all = all.sort(alphasort);
      if (self.mark) {
        for (var i = 0; i < all.length; i++) {
          all[i] = self._mark(all[i]);
        }
        if (self.nodir) {
          all = all.filter(function(e) {
            var notDir = !/\/$/.test(e);
            var c = self.cache[e] || self.cache[makeAbs(self, e)];
            if (notDir && c)
              notDir = c !== "DIR" && !Array.isArray(c);
            return notDir;
          });
        }
      }
      if (self.ignore.length)
        all = all.filter(function(m2) {
          return !isIgnored(self, m2);
        });
      self.found = all;
    }
    function mark(self, p) {
      var abs = makeAbs(self, p);
      var c = self.cache[abs];
      var m = p;
      if (c) {
        var isDir = c === "DIR" || Array.isArray(c);
        var slash = p.slice(-1) === "/";
        if (isDir && !slash)
          m += "/";
        else if (!isDir && slash)
          m = m.slice(0, -1);
        if (m !== p) {
          var mabs = makeAbs(self, m);
          self.statCache[mabs] = self.statCache[abs];
          self.cache[mabs] = self.cache[abs];
        }
      }
      return m;
    }
    function makeAbs(self, f) {
      var abs = f;
      if (f.charAt(0) === "/") {
        abs = path2.join(self.root, f);
      } else if (isAbsolute(f) || f === "") {
        abs = f;
      } else if (self.changedCwd) {
        abs = path2.resolve(self.cwd, f);
      } else {
        abs = path2.resolve(f);
      }
      if (process.platform === "win32")
        abs = abs.replace(/\\/g, "/");
      return abs;
    }
    function isIgnored(self, path3) {
      if (!self.ignore.length)
        return false;
      return self.ignore.some(function(item) {
        return item.matcher.match(path3) || !!(item.gmatcher && item.gmatcher.match(path3));
      });
    }
    function childrenIgnored(self, path3) {
      if (!self.ignore.length)
        return false;
      return self.ignore.some(function(item) {
        return !!(item.gmatcher && item.gmatcher.match(path3));
      });
    }
  }
});

// node_modules/glob/sync.js
var require_sync = __commonJS({
  "node_modules/glob/sync.js"(exports, module2) {
    init_cjs_shims();
    module2.exports = globSync;
    globSync.GlobSync = GlobSync;
    var fs3 = require("fs");
    var rp = require_fs();
    var minimatch = require_minimatch();
    var Minimatch = minimatch.Minimatch;
    var Glob = require_glob().Glob;
    var util = require("util");
    var path2 = require("path");
    var assert = require("assert");
    var isAbsolute = require_path_is_absolute();
    var common = require_common();
    var setopts = common.setopts;
    var ownProp = common.ownProp;
    var childrenIgnored = common.childrenIgnored;
    var isIgnored = common.isIgnored;
    function globSync(pattern, options) {
      if (typeof options === "function" || arguments.length === 3)
        throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
      return new GlobSync(pattern, options).found;
    }
    function GlobSync(pattern, options) {
      if (!pattern)
        throw new Error("must provide pattern");
      if (typeof options === "function" || arguments.length === 3)
        throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
      if (!(this instanceof GlobSync))
        return new GlobSync(pattern, options);
      setopts(this, pattern, options);
      if (this.noprocess)
        return this;
      var n = this.minimatch.set.length;
      this.matches = new Array(n);
      for (var i = 0; i < n; i++) {
        this._process(this.minimatch.set[i], i, false);
      }
      this._finish();
    }
    GlobSync.prototype._finish = function() {
      assert(this instanceof GlobSync);
      if (this.realpath) {
        var self = this;
        this.matches.forEach(function(matchset, index) {
          var set = self.matches[index] = /* @__PURE__ */ Object.create(null);
          for (var p in matchset) {
            try {
              p = self._makeAbs(p);
              var real = rp.realpathSync(p, self.realpathCache);
              set[real] = true;
            } catch (er) {
              if (er.syscall === "stat")
                set[self._makeAbs(p)] = true;
              else
                throw er;
            }
          }
        });
      }
      common.finish(this);
    };
    GlobSync.prototype._process = function(pattern, index, inGlobStar) {
      assert(this instanceof GlobSync);
      var n = 0;
      while (typeof pattern[n] === "string") {
        n++;
      }
      var prefix;
      switch (n) {
        case pattern.length:
          this._processSimple(pattern.join("/"), index);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern.slice(0, n).join("/");
          break;
      }
      var remain = pattern.slice(n);
      var read;
      if (prefix === null)
        read = ".";
      else if (isAbsolute(prefix) || isAbsolute(pattern.join("/"))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = "/" + prefix;
        read = prefix;
      } else
        read = prefix;
      var abs = this._makeAbs(read);
      if (childrenIgnored(this, read))
        return;
      var isGlobStar = remain[0] === minimatch.GLOBSTAR;
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs, remain, index, inGlobStar);
      else
        this._processReaddir(prefix, read, abs, remain, index, inGlobStar);
    };
    GlobSync.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar) {
      var entries = this._readdir(abs, inGlobStar);
      if (!entries)
        return;
      var pn = remain[0];
      var negate = !!this.minimatch.negate;
      var rawGlob = pn._glob;
      var dotOk = this.dot || rawGlob.charAt(0) === ".";
      var matchedEntries = [];
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (e.charAt(0) !== "." || dotOk) {
          var m;
          if (negate && !prefix) {
            m = !e.match(pn);
          } else {
            m = e.match(pn);
          }
          if (m)
            matchedEntries.push(e);
        }
      }
      var len = matchedEntries.length;
      if (len === 0)
        return;
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = /* @__PURE__ */ Object.create(null);
        for (var i = 0; i < len; i++) {
          var e = matchedEntries[i];
          if (prefix) {
            if (prefix.slice(-1) !== "/")
              e = prefix + "/" + e;
            else
              e = prefix + e;
          }
          if (e.charAt(0) === "/" && !this.nomount) {
            e = path2.join(this.root, e);
          }
          this._emitMatch(index, e);
        }
        return;
      }
      remain.shift();
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        var newPattern;
        if (prefix)
          newPattern = [prefix, e];
        else
          newPattern = [e];
        this._process(newPattern.concat(remain), index, inGlobStar);
      }
    };
    GlobSync.prototype._emitMatch = function(index, e) {
      if (isIgnored(this, e))
        return;
      var abs = this._makeAbs(e);
      if (this.mark)
        e = this._mark(e);
      if (this.absolute) {
        e = abs;
      }
      if (this.matches[index][e])
        return;
      if (this.nodir) {
        var c = this.cache[abs];
        if (c === "DIR" || Array.isArray(c))
          return;
      }
      this.matches[index][e] = true;
      if (this.stat)
        this._stat(e);
    };
    GlobSync.prototype._readdirInGlobStar = function(abs) {
      if (this.follow)
        return this._readdir(abs, false);
      var entries;
      var lstat;
      var stat;
      try {
        lstat = fs3.lstatSync(abs);
      } catch (er) {
        if (er.code === "ENOENT") {
          return null;
        }
      }
      var isSym = lstat && lstat.isSymbolicLink();
      this.symlinks[abs] = isSym;
      if (!isSym && lstat && !lstat.isDirectory())
        this.cache[abs] = "FILE";
      else
        entries = this._readdir(abs, false);
      return entries;
    };
    GlobSync.prototype._readdir = function(abs, inGlobStar) {
      var entries;
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs);
      if (ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (!c || c === "FILE")
          return null;
        if (Array.isArray(c))
          return c;
      }
      try {
        return this._readdirEntries(abs, fs3.readdirSync(abs));
      } catch (er) {
        this._readdirError(abs, er);
        return null;
      }
    };
    GlobSync.prototype._readdirEntries = function(abs, entries) {
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i++) {
          var e = entries[i];
          if (abs === "/")
            e = abs + e;
          else
            e = abs + "/" + e;
          this.cache[e] = true;
        }
      }
      this.cache[abs] = entries;
      return entries;
    };
    GlobSync.prototype._readdirError = function(f, er) {
      switch (er.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          var abs = this._makeAbs(f);
          this.cache[abs] = "FILE";
          if (abs === this.cwdAbs) {
            var error = new Error(er.code + " invalid cwd " + this.cwd);
            error.path = this.cwd;
            error.code = er.code;
            throw error;
          }
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f)] = false;
          break;
        default:
          this.cache[this._makeAbs(f)] = false;
          if (this.strict)
            throw er;
          if (!this.silent)
            console.error("glob error", er);
          break;
      }
    };
    GlobSync.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar) {
      var entries = this._readdir(abs, inGlobStar);
      if (!entries)
        return;
      var remainWithoutGlobStar = remain.slice(1);
      var gspref = prefix ? [prefix] : [];
      var noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index, false);
      var len = entries.length;
      var isSym = this.symlinks[abs];
      if (isSym && inGlobStar)
        return;
      for (var i = 0; i < len; i++) {
        var e = entries[i];
        if (e.charAt(0) === "." && !this.dot)
          continue;
        var instead = gspref.concat(entries[i], remainWithoutGlobStar);
        this._process(instead, index, true);
        var below = gspref.concat(entries[i], remain);
        this._process(below, index, true);
      }
    };
    GlobSync.prototype._processSimple = function(prefix, index) {
      var exists = this._stat(prefix);
      if (!this.matches[index])
        this.matches[index] = /* @__PURE__ */ Object.create(null);
      if (!exists)
        return;
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === "/") {
          prefix = path2.join(this.root, prefix);
        } else {
          prefix = path2.resolve(this.root, prefix);
          if (trail)
            prefix += "/";
        }
      }
      if (process.platform === "win32")
        prefix = prefix.replace(/\\/g, "/");
      this._emitMatch(index, prefix);
    };
    GlobSync.prototype._stat = function(f) {
      var abs = this._makeAbs(f);
      var needDir = f.slice(-1) === "/";
      if (f.length > this.maxLength)
        return false;
      if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (Array.isArray(c))
          c = "DIR";
        if (!needDir || c === "DIR")
          return c;
        if (needDir && c === "FILE")
          return false;
      }
      var exists;
      var stat = this.statCache[abs];
      if (!stat) {
        var lstat;
        try {
          lstat = fs3.lstatSync(abs);
        } catch (er) {
          if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
            this.statCache[abs] = false;
            return false;
          }
        }
        if (lstat && lstat.isSymbolicLink()) {
          try {
            stat = fs3.statSync(abs);
          } catch (er) {
            stat = lstat;
          }
        } else {
          stat = lstat;
        }
      }
      this.statCache[abs] = stat;
      var c = true;
      if (stat)
        c = stat.isDirectory() ? "DIR" : "FILE";
      this.cache[abs] = this.cache[abs] || c;
      if (needDir && c === "FILE")
        return false;
      return c;
    };
    GlobSync.prototype._mark = function(p) {
      return common.mark(this, p);
    };
    GlobSync.prototype._makeAbs = function(f) {
      return common.makeAbs(this, f);
    };
  }
});

// node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS({
  "node_modules/wrappy/wrappy.js"(exports, module2) {
    init_cjs_shims();
    module2.exports = wrappy;
    function wrappy(fn, cb) {
      if (fn && cb)
        return wrappy(fn)(cb);
      if (typeof fn !== "function")
        throw new TypeError("need wrapper function");
      Object.keys(fn).forEach(function(k) {
        wrapper[k] = fn[k];
      });
      return wrapper;
      function wrapper() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        var ret = fn.apply(this, args);
        var cb2 = args[args.length - 1];
        if (typeof ret === "function" && ret !== cb2) {
          Object.keys(cb2).forEach(function(k) {
            ret[k] = cb2[k];
          });
        }
        return ret;
      }
    }
  }
});

// node_modules/once/once.js
var require_once = __commonJS({
  "node_modules/once/once.js"(exports, module2) {
    init_cjs_shims();
    var wrappy = require_wrappy();
    module2.exports = wrappy(once);
    module2.exports.strict = wrappy(onceStrict);
    once.proto = once(function() {
      Object.defineProperty(Function.prototype, "once", {
        value: function() {
          return once(this);
        },
        configurable: true
      });
      Object.defineProperty(Function.prototype, "onceStrict", {
        value: function() {
          return onceStrict(this);
        },
        configurable: true
      });
    });
    function once(fn) {
      var f = function() {
        if (f.called)
          return f.value;
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      f.called = false;
      return f;
    }
    function onceStrict(fn) {
      var f = function() {
        if (f.called)
          throw new Error(f.onceError);
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      var name = fn.name || "Function wrapped with `once`";
      f.onceError = name + " shouldn't be called more than once";
      f.called = false;
      return f;
    }
  }
});

// node_modules/inflight/inflight.js
var require_inflight = __commonJS({
  "node_modules/inflight/inflight.js"(exports, module2) {
    init_cjs_shims();
    var wrappy = require_wrappy();
    var reqs = /* @__PURE__ */ Object.create(null);
    var once = require_once();
    module2.exports = wrappy(inflight);
    function inflight(key, cb) {
      if (reqs[key]) {
        reqs[key].push(cb);
        return null;
      } else {
        reqs[key] = [cb];
        return makeres(key);
      }
    }
    function makeres(key) {
      return once(function RES() {
        var cbs = reqs[key];
        var len = cbs.length;
        var args = slice(arguments);
        try {
          for (var i = 0; i < len; i++) {
            cbs[i].apply(null, args);
          }
        } finally {
          if (cbs.length > len) {
            cbs.splice(0, len);
            process.nextTick(function() {
              RES.apply(null, args);
            });
          } else {
            delete reqs[key];
          }
        }
      });
    }
    function slice(args) {
      var length = args.length;
      var array = [];
      for (var i = 0; i < length; i++)
        array[i] = args[i];
      return array;
    }
  }
});

// node_modules/glob/glob.js
var require_glob = __commonJS({
  "node_modules/glob/glob.js"(exports, module2) {
    init_cjs_shims();
    module2.exports = glob;
    var fs3 = require("fs");
    var rp = require_fs();
    var minimatch = require_minimatch();
    var Minimatch = minimatch.Minimatch;
    var inherits = require_inherits();
    var EE = require("events").EventEmitter;
    var path2 = require("path");
    var assert = require("assert");
    var isAbsolute = require_path_is_absolute();
    var globSync = require_sync();
    var common = require_common();
    var setopts = common.setopts;
    var ownProp = common.ownProp;
    var inflight = require_inflight();
    var util = require("util");
    var childrenIgnored = common.childrenIgnored;
    var isIgnored = common.isIgnored;
    var once = require_once();
    function glob(pattern, options, cb) {
      if (typeof options === "function")
        cb = options, options = {};
      if (!options)
        options = {};
      if (options.sync) {
        if (cb)
          throw new TypeError("callback provided to sync glob");
        return globSync(pattern, options);
      }
      return new Glob(pattern, options, cb);
    }
    glob.sync = globSync;
    var GlobSync = glob.GlobSync = globSync.GlobSync;
    glob.glob = glob;
    function extend(origin, add) {
      if (add === null || typeof add !== "object") {
        return origin;
      }
      var keys = Object.keys(add);
      var i = keys.length;
      while (i--) {
        origin[keys[i]] = add[keys[i]];
      }
      return origin;
    }
    glob.hasMagic = function(pattern, options_) {
      var options = extend({}, options_);
      options.noprocess = true;
      var g = new Glob(pattern, options);
      var set = g.minimatch.set;
      if (!pattern)
        return false;
      if (set.length > 1)
        return true;
      for (var j = 0; j < set[0].length; j++) {
        if (typeof set[0][j] !== "string")
          return true;
      }
      return false;
    };
    glob.Glob = Glob;
    inherits(Glob, EE);
    function Glob(pattern, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = null;
      }
      if (options && options.sync) {
        if (cb)
          throw new TypeError("callback provided to sync glob");
        return new GlobSync(pattern, options);
      }
      if (!(this instanceof Glob))
        return new Glob(pattern, options, cb);
      setopts(this, pattern, options);
      this._didRealPath = false;
      var n = this.minimatch.set.length;
      this.matches = new Array(n);
      if (typeof cb === "function") {
        cb = once(cb);
        this.on("error", cb);
        this.on("end", function(matches) {
          cb(null, matches);
        });
      }
      var self = this;
      this._processing = 0;
      this._emitQueue = [];
      this._processQueue = [];
      this.paused = false;
      if (this.noprocess)
        return this;
      if (n === 0)
        return done();
      var sync = true;
      for (var i = 0; i < n; i++) {
        this._process(this.minimatch.set[i], i, false, done);
      }
      sync = false;
      function done() {
        --self._processing;
        if (self._processing <= 0) {
          if (sync) {
            process.nextTick(function() {
              self._finish();
            });
          } else {
            self._finish();
          }
        }
      }
    }
    Glob.prototype._finish = function() {
      assert(this instanceof Glob);
      if (this.aborted)
        return;
      if (this.realpath && !this._didRealpath)
        return this._realpath();
      common.finish(this);
      this.emit("end", this.found);
    };
    Glob.prototype._realpath = function() {
      if (this._didRealpath)
        return;
      this._didRealpath = true;
      var n = this.matches.length;
      if (n === 0)
        return this._finish();
      var self = this;
      for (var i = 0; i < this.matches.length; i++)
        this._realpathSet(i, next);
      function next() {
        if (--n === 0)
          self._finish();
      }
    };
    Glob.prototype._realpathSet = function(index, cb) {
      var matchset = this.matches[index];
      if (!matchset)
        return cb();
      var found = Object.keys(matchset);
      var self = this;
      var n = found.length;
      if (n === 0)
        return cb();
      var set = this.matches[index] = /* @__PURE__ */ Object.create(null);
      found.forEach(function(p, i) {
        p = self._makeAbs(p);
        rp.realpath(p, self.realpathCache, function(er, real) {
          if (!er)
            set[real] = true;
          else if (er.syscall === "stat")
            set[p] = true;
          else
            self.emit("error", er);
          if (--n === 0) {
            self.matches[index] = set;
            cb();
          }
        });
      });
    };
    Glob.prototype._mark = function(p) {
      return common.mark(this, p);
    };
    Glob.prototype._makeAbs = function(f) {
      return common.makeAbs(this, f);
    };
    Glob.prototype.abort = function() {
      this.aborted = true;
      this.emit("abort");
    };
    Glob.prototype.pause = function() {
      if (!this.paused) {
        this.paused = true;
        this.emit("pause");
      }
    };
    Glob.prototype.resume = function() {
      if (this.paused) {
        this.emit("resume");
        this.paused = false;
        if (this._emitQueue.length) {
          var eq = this._emitQueue.slice(0);
          this._emitQueue.length = 0;
          for (var i = 0; i < eq.length; i++) {
            var e = eq[i];
            this._emitMatch(e[0], e[1]);
          }
        }
        if (this._processQueue.length) {
          var pq = this._processQueue.slice(0);
          this._processQueue.length = 0;
          for (var i = 0; i < pq.length; i++) {
            var p = pq[i];
            this._processing--;
            this._process(p[0], p[1], p[2], p[3]);
          }
        }
      }
    };
    Glob.prototype._process = function(pattern, index, inGlobStar, cb) {
      assert(this instanceof Glob);
      assert(typeof cb === "function");
      if (this.aborted)
        return;
      this._processing++;
      if (this.paused) {
        this._processQueue.push([pattern, index, inGlobStar, cb]);
        return;
      }
      var n = 0;
      while (typeof pattern[n] === "string") {
        n++;
      }
      var prefix;
      switch (n) {
        case pattern.length:
          this._processSimple(pattern.join("/"), index, cb);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern.slice(0, n).join("/");
          break;
      }
      var remain = pattern.slice(n);
      var read;
      if (prefix === null)
        read = ".";
      else if (isAbsolute(prefix) || isAbsolute(pattern.join("/"))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = "/" + prefix;
        read = prefix;
      } else
        read = prefix;
      var abs = this._makeAbs(read);
      if (childrenIgnored(this, read))
        return cb();
      var isGlobStar = remain[0] === minimatch.GLOBSTAR;
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb);
      else
        this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb);
    };
    Glob.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar, cb) {
      var self = this;
      this._readdir(abs, inGlobStar, function(er, entries) {
        return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
      });
    };
    Glob.prototype._processReaddir2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
      if (!entries)
        return cb();
      var pn = remain[0];
      var negate = !!this.minimatch.negate;
      var rawGlob = pn._glob;
      var dotOk = this.dot || rawGlob.charAt(0) === ".";
      var matchedEntries = [];
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (e.charAt(0) !== "." || dotOk) {
          var m;
          if (negate && !prefix) {
            m = !e.match(pn);
          } else {
            m = e.match(pn);
          }
          if (m)
            matchedEntries.push(e);
        }
      }
      var len = matchedEntries.length;
      if (len === 0)
        return cb();
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = /* @__PURE__ */ Object.create(null);
        for (var i = 0; i < len; i++) {
          var e = matchedEntries[i];
          if (prefix) {
            if (prefix !== "/")
              e = prefix + "/" + e;
            else
              e = prefix + e;
          }
          if (e.charAt(0) === "/" && !this.nomount) {
            e = path2.join(this.root, e);
          }
          this._emitMatch(index, e);
        }
        return cb();
      }
      remain.shift();
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        var newPattern;
        if (prefix) {
          if (prefix !== "/")
            e = prefix + "/" + e;
          else
            e = prefix + e;
        }
        this._process([e].concat(remain), index, inGlobStar, cb);
      }
      cb();
    };
    Glob.prototype._emitMatch = function(index, e) {
      if (this.aborted)
        return;
      if (isIgnored(this, e))
        return;
      if (this.paused) {
        this._emitQueue.push([index, e]);
        return;
      }
      var abs = isAbsolute(e) ? e : this._makeAbs(e);
      if (this.mark)
        e = this._mark(e);
      if (this.absolute)
        e = abs;
      if (this.matches[index][e])
        return;
      if (this.nodir) {
        var c = this.cache[abs];
        if (c === "DIR" || Array.isArray(c))
          return;
      }
      this.matches[index][e] = true;
      var st = this.statCache[abs];
      if (st)
        this.emit("stat", e, st);
      this.emit("match", e);
    };
    Glob.prototype._readdirInGlobStar = function(abs, cb) {
      if (this.aborted)
        return;
      if (this.follow)
        return this._readdir(abs, false, cb);
      var lstatkey = "lstat\0" + abs;
      var self = this;
      var lstatcb = inflight(lstatkey, lstatcb_);
      if (lstatcb)
        fs3.lstat(abs, lstatcb);
      function lstatcb_(er, lstat) {
        if (er && er.code === "ENOENT")
          return cb();
        var isSym = lstat && lstat.isSymbolicLink();
        self.symlinks[abs] = isSym;
        if (!isSym && lstat && !lstat.isDirectory()) {
          self.cache[abs] = "FILE";
          cb();
        } else
          self._readdir(abs, false, cb);
      }
    };
    Glob.prototype._readdir = function(abs, inGlobStar, cb) {
      if (this.aborted)
        return;
      cb = inflight("readdir\0" + abs + "\0" + inGlobStar, cb);
      if (!cb)
        return;
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs, cb);
      if (ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (!c || c === "FILE")
          return cb();
        if (Array.isArray(c))
          return cb(null, c);
      }
      var self = this;
      fs3.readdir(abs, readdirCb(this, abs, cb));
    };
    function readdirCb(self, abs, cb) {
      return function(er, entries) {
        if (er)
          self._readdirError(abs, er, cb);
        else
          self._readdirEntries(abs, entries, cb);
      };
    }
    Glob.prototype._readdirEntries = function(abs, entries, cb) {
      if (this.aborted)
        return;
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i++) {
          var e = entries[i];
          if (abs === "/")
            e = abs + e;
          else
            e = abs + "/" + e;
          this.cache[e] = true;
        }
      }
      this.cache[abs] = entries;
      return cb(null, entries);
    };
    Glob.prototype._readdirError = function(f, er, cb) {
      if (this.aborted)
        return;
      switch (er.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          var abs = this._makeAbs(f);
          this.cache[abs] = "FILE";
          if (abs === this.cwdAbs) {
            var error = new Error(er.code + " invalid cwd " + this.cwd);
            error.path = this.cwd;
            error.code = er.code;
            this.emit("error", error);
            this.abort();
          }
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f)] = false;
          break;
        default:
          this.cache[this._makeAbs(f)] = false;
          if (this.strict) {
            this.emit("error", er);
            this.abort();
          }
          if (!this.silent)
            console.error("glob error", er);
          break;
      }
      return cb();
    };
    Glob.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar, cb) {
      var self = this;
      this._readdir(abs, inGlobStar, function(er, entries) {
        self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
      });
    };
    Glob.prototype._processGlobStar2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
      if (!entries)
        return cb();
      var remainWithoutGlobStar = remain.slice(1);
      var gspref = prefix ? [prefix] : [];
      var noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index, false, cb);
      var isSym = this.symlinks[abs];
      var len = entries.length;
      if (isSym && inGlobStar)
        return cb();
      for (var i = 0; i < len; i++) {
        var e = entries[i];
        if (e.charAt(0) === "." && !this.dot)
          continue;
        var instead = gspref.concat(entries[i], remainWithoutGlobStar);
        this._process(instead, index, true, cb);
        var below = gspref.concat(entries[i], remain);
        this._process(below, index, true, cb);
      }
      cb();
    };
    Glob.prototype._processSimple = function(prefix, index, cb) {
      var self = this;
      this._stat(prefix, function(er, exists) {
        self._processSimple2(prefix, index, er, exists, cb);
      });
    };
    Glob.prototype._processSimple2 = function(prefix, index, er, exists, cb) {
      if (!this.matches[index])
        this.matches[index] = /* @__PURE__ */ Object.create(null);
      if (!exists)
        return cb();
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === "/") {
          prefix = path2.join(this.root, prefix);
        } else {
          prefix = path2.resolve(this.root, prefix);
          if (trail)
            prefix += "/";
        }
      }
      if (process.platform === "win32")
        prefix = prefix.replace(/\\/g, "/");
      this._emitMatch(index, prefix);
      cb();
    };
    Glob.prototype._stat = function(f, cb) {
      var abs = this._makeAbs(f);
      var needDir = f.slice(-1) === "/";
      if (f.length > this.maxLength)
        return cb();
      if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (Array.isArray(c))
          c = "DIR";
        if (!needDir || c === "DIR")
          return cb(null, c);
        if (needDir && c === "FILE")
          return cb();
      }
      var exists;
      var stat = this.statCache[abs];
      if (stat !== void 0) {
        if (stat === false)
          return cb(null, stat);
        else {
          var type = stat.isDirectory() ? "DIR" : "FILE";
          if (needDir && type === "FILE")
            return cb();
          else
            return cb(null, type, stat);
        }
      }
      var self = this;
      var statcb = inflight("stat\0" + abs, lstatcb_);
      if (statcb)
        fs3.lstat(abs, statcb);
      function lstatcb_(er, lstat) {
        if (lstat && lstat.isSymbolicLink()) {
          return fs3.stat(abs, function(er2, stat2) {
            if (er2)
              self._stat2(f, abs, null, lstat, cb);
            else
              self._stat2(f, abs, er2, stat2, cb);
          });
        } else {
          self._stat2(f, abs, er, lstat, cb);
        }
      }
    };
    Glob.prototype._stat2 = function(f, abs, er, stat, cb) {
      if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
        this.statCache[abs] = false;
        return cb();
      }
      var needDir = f.slice(-1) === "/";
      this.statCache[abs] = stat;
      if (abs.slice(-1) === "/" && stat && !stat.isDirectory())
        return cb(null, false, stat);
      var c = true;
      if (stat)
        c = stat.isDirectory() ? "DIR" : "FILE";
      this.cache[abs] = this.cache[abs] || c;
      if (needDir && c === "FILE")
        return cb();
      return cb(null, c, stat);
    };
  }
});

// node_modules/rmfr/node_modules/rimraf/rimraf.js
var require_rimraf = __commonJS({
  "node_modules/rmfr/node_modules/rimraf/rimraf.js"(exports, module2) {
    init_cjs_shims();
    module2.exports = rimraf;
    rimraf.sync = rimrafSync;
    var assert = require("assert");
    var path2 = require("path");
    var fs3 = require("fs");
    var glob = void 0;
    try {
      glob = require_glob();
    } catch (_err) {
    }
    var _0666 = parseInt("666", 8);
    var defaultGlobOpts = {
      nosort: true,
      silent: true
    };
    var timeout = 0;
    var isWindows = process.platform === "win32";
    function defaults(options) {
      var methods = [
        "unlink",
        "chmod",
        "stat",
        "lstat",
        "rmdir",
        "readdir"
      ];
      methods.forEach(function(m) {
        options[m] = options[m] || fs3[m];
        m = m + "Sync";
        options[m] = options[m] || fs3[m];
      });
      options.maxBusyTries = options.maxBusyTries || 3;
      options.emfileWait = options.emfileWait || 1e3;
      if (options.glob === false) {
        options.disableGlob = true;
      }
      if (options.disableGlob !== true && glob === void 0) {
        throw Error("glob dependency not found, set `options.disableGlob = true` if intentional");
      }
      options.disableGlob = options.disableGlob || false;
      options.glob = options.glob || defaultGlobOpts;
    }
    function rimraf(p, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      assert(p, "rimraf: missing path");
      assert.equal(typeof p, "string", "rimraf: path should be a string");
      assert.equal(typeof cb, "function", "rimraf: callback function required");
      assert(options, "rimraf: invalid options argument provided");
      assert.equal(typeof options, "object", "rimraf: options should be object");
      defaults(options);
      var busyTries = 0;
      var errState = null;
      var n = 0;
      if (options.disableGlob || !glob.hasMagic(p))
        return afterGlob(null, [p]);
      options.lstat(p, function(er, stat) {
        if (!er)
          return afterGlob(null, [p]);
        glob(p, options.glob, afterGlob);
      });
      function next(er) {
        errState = errState || er;
        if (--n === 0)
          cb(errState);
      }
      function afterGlob(er, results) {
        if (er)
          return cb(er);
        n = results.length;
        if (n === 0)
          return cb();
        results.forEach(function(p2) {
          rimraf_(p2, options, function CB(er2) {
            if (er2) {
              if ((er2.code === "EBUSY" || er2.code === "ENOTEMPTY" || er2.code === "EPERM") && busyTries < options.maxBusyTries) {
                busyTries++;
                var time = busyTries * 100;
                return setTimeout(function() {
                  rimraf_(p2, options, CB);
                }, time);
              }
              if (er2.code === "EMFILE" && timeout < options.emfileWait) {
                return setTimeout(function() {
                  rimraf_(p2, options, CB);
                }, timeout++);
              }
              if (er2.code === "ENOENT")
                er2 = null;
            }
            timeout = 0;
            next(er2);
          });
        });
      }
    }
    function rimraf_(p, options, cb) {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.lstat(p, function(er, st) {
        if (er && er.code === "ENOENT")
          return cb(null);
        if (er && er.code === "EPERM" && isWindows)
          fixWinEPERM(p, options, er, cb);
        if (st && st.isDirectory())
          return rmdir(p, options, er, cb);
        options.unlink(p, function(er2) {
          if (er2) {
            if (er2.code === "ENOENT")
              return cb(null);
            if (er2.code === "EPERM")
              return isWindows ? fixWinEPERM(p, options, er2, cb) : rmdir(p, options, er2, cb);
            if (er2.code === "EISDIR")
              return rmdir(p, options, er2, cb);
          }
          return cb(er2);
        });
      });
    }
    function fixWinEPERM(p, options, er, cb) {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      if (er)
        assert(er instanceof Error);
      options.chmod(p, _0666, function(er2) {
        if (er2)
          cb(er2.code === "ENOENT" ? null : er);
        else
          options.stat(p, function(er3, stats) {
            if (er3)
              cb(er3.code === "ENOENT" ? null : er);
            else if (stats.isDirectory())
              rmdir(p, options, er, cb);
            else
              options.unlink(p, cb);
          });
      });
    }
    function fixWinEPERMSync(p, options, er) {
      assert(p);
      assert(options);
      if (er)
        assert(er instanceof Error);
      try {
        options.chmodSync(p, _0666);
      } catch (er2) {
        if (er2.code === "ENOENT")
          return;
        else
          throw er;
      }
      try {
        var stats = options.statSync(p);
      } catch (er3) {
        if (er3.code === "ENOENT")
          return;
        else
          throw er;
      }
      if (stats.isDirectory())
        rmdirSync(p, options, er);
      else
        options.unlinkSync(p);
    }
    function rmdir(p, options, originalEr, cb) {
      assert(p);
      assert(options);
      if (originalEr)
        assert(originalEr instanceof Error);
      assert(typeof cb === "function");
      options.rmdir(p, function(er) {
        if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM"))
          rmkids(p, options, cb);
        else if (er && er.code === "ENOTDIR")
          cb(originalEr);
        else
          cb(er);
      });
    }
    function rmkids(p, options, cb) {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.readdir(p, function(er, files) {
        if (er)
          return cb(er);
        var n = files.length;
        if (n === 0)
          return options.rmdir(p, cb);
        var errState;
        files.forEach(function(f) {
          rimraf(path2.join(p, f), options, function(er2) {
            if (errState)
              return;
            if (er2)
              return cb(errState = er2);
            if (--n === 0)
              options.rmdir(p, cb);
          });
        });
      });
    }
    function rimrafSync(p, options) {
      options = options || {};
      defaults(options);
      assert(p, "rimraf: missing path");
      assert.equal(typeof p, "string", "rimraf: path should be a string");
      assert(options, "rimraf: missing options");
      assert.equal(typeof options, "object", "rimraf: options should be object");
      var results;
      if (options.disableGlob || !glob.hasMagic(p)) {
        results = [p];
      } else {
        try {
          options.lstatSync(p);
          results = [p];
        } catch (er) {
          results = glob.sync(p, options.glob);
        }
      }
      if (!results.length)
        return;
      for (var i = 0; i < results.length; i++) {
        var p = results[i];
        try {
          var st = options.lstatSync(p);
        } catch (er) {
          if (er.code === "ENOENT")
            return;
          if (er.code === "EPERM" && isWindows)
            fixWinEPERMSync(p, options, er);
        }
        try {
          if (st && st.isDirectory())
            rmdirSync(p, options, null);
          else
            options.unlinkSync(p);
        } catch (er) {
          if (er.code === "ENOENT")
            return;
          if (er.code === "EPERM")
            return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er);
          if (er.code !== "EISDIR")
            throw er;
          rmdirSync(p, options, er);
        }
      }
    }
    function rmdirSync(p, options, originalEr) {
      assert(p);
      assert(options);
      if (originalEr)
        assert(originalEr instanceof Error);
      try {
        options.rmdirSync(p);
      } catch (er) {
        if (er.code === "ENOENT")
          return;
        if (er.code === "ENOTDIR")
          throw originalEr;
        if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")
          rmkidsSync(p, options);
      }
    }
    function rmkidsSync(p, options) {
      assert(p);
      assert(options);
      options.readdirSync(p).forEach(function(f) {
        rimrafSync(path2.join(p, f), options);
      });
      var retries = isWindows ? 100 : 1;
      var i = 0;
      do {
        var threw = true;
        try {
          var ret = options.rmdirSync(p, options);
          threw = false;
          return ret;
        } finally {
          if (++i < retries && threw)
            continue;
        }
      } while (true);
    }
  }
});

// node_modules/rmfr/index.js
var require_rmfr = __commonJS({
  "node_modules/rmfr/index.js"(exports, module2) {
    "use strict";
    init_cjs_shims();
    var { promisify } = require("util");
    var { resolve } = require("path");
    var assertValidGlobOpts = require_assert_valid_glob_opts();
    var { chmod, readdir, rmdir, unlink } = require_graceful_fs();
    var { hasMagic } = require_glob();
    var inspectWithKind = require_inspect_with_kind();
    var rimraf = require_rimraf();
    var RIMRAF_DOC_URL = "https://github.com/isaacs/rimraf#options";
    var SUPPORTED_FS_METHODS = [
      "unlink",
      "chmod",
      "stat",
      "lstat",
      "rmdir",
      "readdir"
    ];
    var UNSUPPORTED_GLOB_OPTIONS = [
      "mark",
      "stat"
    ];
    var FORCED_GLOB_OPTIONS = [
      "nosort",
      "nounique"
    ];
    var promisifiedRimraf = promisify(rimraf);
    module2.exports = async function rmfr2(...args) {
      const argLen = args.length;
      if (argLen !== 1 && argLen !== 2) {
        throw new RangeError(`Expected 1 or 2 arguments (<string>[, <Object>]), but got ${argLen === 0 ? "no" : argLen} arguments.`);
      }
      const defaultOptions = {
        glob: false,
        chmod,
        readdir,
        rmdir,
        unlink
      };
      if (argLen === 1) {
        return promisifiedRimraf(args[0], defaultOptions);
      }
      const [path2] = args;
      if (typeof args[1] !== "object") {
        throw new TypeError(`Expected an option object passed to rimraf (${RIMRAF_DOC_URL}), but got ${inspectWithKind(args[1])}.`);
      }
      const options = Object.assign(defaultOptions, args[1]);
      const errors = [];
      for (const method of SUPPORTED_FS_METHODS) {
        if (options[method] !== void 0 && typeof options[method] !== "function") {
          errors.push(`\`${method}\` option must be a function, but got ${inspectWithKind(options[method])}.`);
        }
      }
      if (options.maxBusyTries !== void 0 && typeof options.maxBusyTries !== "number") {
        errors.push(`\`maxBusyTries\` option must be a number, but got ${inspectWithKind(options.maxBusyTries)}.`);
      }
      if (options.emfileWait !== void 0 && typeof options.emfileWait !== "number") {
        errors.push(`\`emfileWait\` option must be a number, but got ${inspectWithKind(options.emfileWait)}.`);
      }
      if (options.disableGlob !== void 0) {
        errors.push(`rmfr doesn't support \`disableGlob\` option, but a value ${inspectWithKind(options.disableGlob)} was provided. rmfr disables glob feature by default.`);
      }
      const defaultGlobOptions = {
        nosort: true,
        nounique: true,
        silent: true
      };
      if (options.glob === true) {
        options.glob = defaultGlobOptions;
      } else if (typeof options.glob === "object") {
        assertValidGlobOpts(options.glob);
        const hasCwdOption = options.glob.cwd !== void 0;
        for (const unsupportedGlobOption of UNSUPPORTED_GLOB_OPTIONS) {
          const val = options.glob[unsupportedGlobOption];
          if (val) {
            errors.push(`rmfr doesn't support \`${unsupportedGlobOption}\` option in \`glob\` option, but got ${inspectWithKind(val)}.`);
          }
        }
        for (const forcedGlobOption of FORCED_GLOB_OPTIONS) {
          const val = options.glob[forcedGlobOption];
          if (val === false) {
            errors.push(`rmfr doesn't allow \`${forcedGlobOption}\` option in \`glob\` option to be disabled, but \`false\` was passed to it.`);
          }
        }
        options.glob = Object.assign(defaultOptions, options.glob, {
          absolute: hasCwdOption
        });
        if (errors.length === 0 && hasCwdOption && !hasMagic(path2, options.glob)) {
          return promisifiedRimraf(resolve(options.glob.cwd, path2), Object.assign(options, {
            disableGlob: true
          }));
        }
      } else if (options.glob !== false) {
        errors.push(`\`glob\` option must be an object passed to \`glob\` or a Boolean value, but got ${inspectWithKind(options.glob)}.`);
      }
      if (errors.length === 1) {
        throw new TypeError(errors[0]);
      }
      if (errors.length !== 0) {
        throw new TypeError(`There was ${errors.length} errors in rimraf options you provided:
${errors.map((error) => `  * ${error}`).join("\n")}
`);
      }
      return promisifiedRimraf(path2, options);
    };
  }
});

// src/cli.ts
init_cjs_shims();
var import_yargs = __toESM(require("yargs/yargs"));
var import_helpers = require("yargs/helpers");
var import_promises2 = __toESM(require("fs/promises"));

// src/index.ts
init_cjs_shims();

// src/get-tree-from-sql.ts
init_cjs_shims();
var pgParser2 = __toESM(require("pgsql-parser"));

// src/deparse-pg.ts
init_cjs_shims();
var pgParser = __toESM(require("pgsql-parser"));
var deparsePg = (exp) => {
  if ("DefElem" in exp) {
    if (exp.DefElem.defname === "owned_by") {
      return `OWNED BY ${"List" in exp.DefElem.arg ? exp.DefElem.arg.List.items.map(deparsePg).join(".") : deparsePg(exp.DefElem.arg)}`;
    } else {
      throw new Error(`Unsupported DefElem: ${JSON.stringify(exp)}`);
    }
  }
  if ("String" in exp) {
    return exp.String.str;
  }
  if ("AlterSeqStmt" in exp) {
    const { sequence, options } = exp.AlterSeqStmt;
    console.log({
      sequence: ``,
      options: options.map(deparsePg)
    });
    return `ALTER SEQUENCE ${sequence.schemaname}.${sequence.relname} ${options.map(deparsePg).join(" ")}`;
  }
  return pgParser.deparse(exp);
};
var deparse_pg_default = deparsePg;

// src/get-tree-from-sql.ts
var getTreeFromSQL = (content, opts = {}) => {
  var _a, _b, _c, _d;
  const statements = pgParser2.parse(content).map((s) => s.RawStmt.stmt);
  const db = {
    schemas: {},
    extensions: [],
    misc: []
  };
  const unassignedSequences = [];
  function createSchemaIfNotExists(schemaname) {
    if (!db.schemas[schemaname])
      db.schemas[schemaname] = {
        name: schemaname,
        tables: {},
        views: {},
        functions: {},
        domains: {},
        grants: [],
        _tablelessSequences: {},
        owner: ""
      };
  }
  function createTableIfNotExists(schemaname, tablename) {
    const schema = db.schemas[schemaname];
    if (!schema.tables[tablename])
      schema.tables[tablename] = {
        name: tablename,
        columns: [],
        indexes: {},
        triggers: {},
        grants: [],
        owner: "",
        sequences: [],
        query: "",
        policies: {},
        rules: {},
        alterations: []
      };
  }
  function findSequence(schemaname, sequencename) {
    const schema = db.schemas[schemaname];
    if (schema._tablelessSequences[sequencename])
      return schema._tablelessSequences[sequencename];
    for (const tableName in schema.tables) {
      const table = schema.tables[tableName];
      const seq = table.sequences.find((s) => s.name === sequencename);
      if (seq)
        return seq;
    }
    throw new Error(`Couldn't find sequence: ${schemaname}.${sequencename}`);
  }
  for (const stmt of statements) {
    try {
      if ("CreateSchemaStmt" in stmt) {
        createSchemaIfNotExists(stmt.CreateSchemaStmt.schemaname);
        continue;
      }
      if ("AlterOwnerStmt" in stmt) {
        const { objectType, object, newowner } = stmt.AlterOwnerStmt;
        const targets = object.List ? object.List.items.map((item) => deparse_pg_default(item)) : [deparse_pg_default(object)];
        const targetName = targets[0];
        if (objectType === "OBJECT_SCHEMA") {
          createSchemaIfNotExists(targetName);
          db.schemas[targetName].owner = newowner.rolename;
        } else if (objectType === "OBJECT_FUNCTION") {
          const [schemaname, funcname_raw] = targetName.split(".");
          const funcname = funcname_raw.split("(")[0].trim();
          db.schemas[schemaname].functions[funcname].owner = newowner.rolename;
        } else if (objectType === "OBJECT_DOMAIN") {
          if (targetName.includes("\n")) {
            const [schema, domainname] = targetName.split("\n").map((t) => t.trim()).filter((t) => t.length > 0);
            db.schemas[schema].domains[domainname].owner = newowner.rolename;
          } else {
            const schema = targetName;
            const domainname = targets[1];
            db.schemas[schema].domains[domainname].owner = newowner.rolename;
          }
        } else {
          throw new Error(`Unsupported object type in AlterOwnerStmt: ${objectType}`);
        }
        continue;
      }
      if ("AlterSeqStmt" in stmt) {
        const { sequence, options } = stmt.AlterSeqStmt;
        const ownedByDef = options.find((o) => o.DefElem.defname === "owned_by");
        if (!ownedByDef)
          throw new Error("Only ownernership change alter sequences are implemented");
        const newowner = "List" in ownedByDef.DefElem.arg ? ownedByDef.DefElem.arg.List.items.map(deparse_pg_default).join(".") : deparse_pg_default(ownedByDef.DefElem.arg);
        const seq = findSequence(sequence.schemaname, sequence.relname);
        if (seq.owner)
          throw new Error("Sequence owner has been set more than once (not implemented)");
        seq.owner = newowner;
        delete db.schemas[sequence.schemaname]._tablelessSequences[sequence.relname];
        const [, ownerTableName] = newowner.split(".");
        db.schemas[sequence.schemaname].tables[ownerTableName].sequences.push(seq);
        continue;
      }
      if ("CreateStmt" in stmt) {
        const { schemaname, relname } = stmt.CreateStmt.relation;
        const table = {
          name: relname,
          columns: stmt.CreateStmt.tableElts.filter((a) => "ColumnDef" in a).map((a) => {
            const { colname, typeName } = a.ColumnDef;
            let type = typeName.names.map(deparse_pg_default).pop();
            if (typeName.arrayBounds) {
              type += "[]";
            }
            return { name: colname, type, query: deparse_pg_default(a), comments: [] };
          }),
          query: deparse_pg_default(stmt),
          alterations: [],
          policies: {},
          triggers: {},
          rules: {},
          indexes: {},
          sequences: [],
          grants: [],
          owner: ""
        };
        createSchemaIfNotExists(schemaname);
        createTableIfNotExists(schemaname, relname);
        db.schemas[schemaname].tables[relname] = __spreadValues(__spreadValues({}, db.schemas[schemaname].tables[relname]), table);
        continue;
      }
      if ("CreateFunctionStmt" in stmt) {
        const {
          funcname: fullFuncName,
          returnType,
          options
        } = stmt.CreateFunctionStmt;
        const [schemaname, funcname] = deparse_pg_default(fullFuncName).replace("\n\n", ".").split(".");
        createSchemaIfNotExists(schemaname);
        db.schemas[schemaname].functions[funcname] = {
          name: funcname,
          query: deparse_pg_default(stmt),
          owner: ""
        };
        continue;
      }
      if ("CreateTrigStmt" in stmt) {
        const {
          relation: { schemaname, relname },
          trigname,
          funcname,
          row,
          timing,
          events
        } = stmt.CreateTrigStmt;
        db.schemas[schemaname].tables[relname].triggers[trigname] = {
          name: trigname,
          functionName: deparse_pg_default(funcname),
          query: deparse_pg_default(stmt)
        };
        continue;
      }
      if ("CreatePolicyStmt" in stmt) {
        const { policy_name, table, cmd_name, permissive, roles, qual } = stmt.CreatePolicyStmt;
        db.schemas[table.schemaname].tables[table.relname].policies[policy_name] = {
          name: policy_name,
          query: deparse_pg_default(stmt)
        };
        continue;
      }
      if ("ViewStmt" in stmt) {
        const { view, query } = stmt.ViewStmt;
        createSchemaIfNotExists(view.schemaname);
        db.schemas[view.schemaname].views[view.relname] = {
          name: view.relname,
          columns: [],
          grants: [],
          triggers: {},
          alterations: [],
          query: deparse_pg_default(query),
          owner: ""
        };
        continue;
      }
      if ("CreateSeqStmt" in stmt) {
        const { schemaname, relname } = stmt.CreateSeqStmt.sequence;
        createSchemaIfNotExists(schemaname);
        db.schemas[schemaname]._tablelessSequences[relname] = {
          name: relname,
          grants: [],
          alterations: [],
          owner: "",
          query: deparse_pg_default(stmt)
        };
        continue;
      }
      if ("AlterTableStmt" in stmt) {
        const { schemaname, relname } = stmt.AlterTableStmt.relation;
        createSchemaIfNotExists(schemaname);
        createTableIfNotExists(schemaname, relname);
        const target = db.schemas[schemaname].tables[relname] || db.schemas[schemaname].views[relname] || db.schemas[schemaname]._tablelessSequences[relname];
        try {
          target.alterations.push({
            query: deparse_pg_default(stmt)
          });
        } catch (error) {
        }
        continue;
      }
      if ("GrantStmt" in stmt) {
        const { is_grant, targtype, objtype, objects, grantees } = stmt.GrantStmt;
        const targetName = deparse_pg_default(objects);
        if (objtype === "OBJECT_SCHEMA") {
          (_a = db.schemas[targetName]) == null ? void 0 : _a.grants.push({
            query: deparse_pg_default(stmt)
          });
        } else if (objtype === "OBJECT_TABLE") {
          const [schemaname, tablename] = targetName.split(".");
          const target = (_d = (_b = db.schemas[schemaname]) == null ? void 0 : _b.tables[tablename]) != null ? _d : (_c = db.schemas[schemaname]) == null ? void 0 : _c.views[tablename];
          target == null ? void 0 : target.grants.push({
            query: deparse_pg_default(stmt)
          });
        } else if (objtype === "OBJECT_SEQUENCE") {
          const [schemaname, seqname] = targetName.split(".");
          findSequence(schemaname, seqname).grants.push({
            query: deparse_pg_default(stmt)
          });
        } else {
          throw new Error(`Unhandled objtype in GrantStmt: "${objtype}"`);
        }
        continue;
      }
      if ("CreateExtensionStmt" in stmt) {
        db.extensions.push({
          query: deparse_pg_default(stmt),
          name: stmt.CreateExtensionStmt.extname
        });
        continue;
      }
      if ("IndexStmt" in stmt) {
        const { idxname, relation } = stmt.IndexStmt;
        db.schemas[relation.schemaname].tables[relation.relname].indexes[idxname] = {
          name: idxname,
          query: deparse_pg_default(stmt)
        };
        continue;
      }
      if ("VariableSetStmt" in stmt || "SelectStmt" in stmt || "CompositeTypeStmt" in stmt) {
        db.misc.push({ query: deparse_pg_default(stmt) });
        continue;
      }
      if ("CommentStmt" in stmt) {
        if (stmt.CommentStmt.objtype === "OBJECT_COLUMN") {
          try {
            const [schema, table, columnName] = stmt.CommentStmt.object.List.items.map((item) => item.String.str);
            const column = db.schemas[schema].tables[table].columns.find((col) => col.name === columnName);
            column.comments.push({
              comment: stmt.CommentStmt.comment,
              query: deparse_pg_default(stmt)
            });
          } catch (e) {
            db.misc.push({ query: deparse_pg_default(stmt) });
          }
        } else {
          db.misc.push({ query: deparse_pg_default(stmt) });
        }
        continue;
      }
      if ("CreateDomainStmt" in stmt) {
        const [schemaname, domainname] = deparse_pg_default(stmt.CreateDomainStmt.domainname).replace("\n\n", ".").split(".");
        if (typeof domainname === "undefined") {
          continue;
        }
        createSchemaIfNotExists(schemaname);
        db.schemas[schemaname].domains[domainname] = {
          name: domainname,
          type: deparse_pg_default(stmt.CreateDomainStmt.typeName.names),
          owner: ""
        };
        continue;
      }
      if ("RuleStmt" in stmt) {
        const schemaname = stmt.RuleStmt.relation.schemaname;
        const relname = stmt.RuleStmt.relation.relname;
        createSchemaIfNotExists(schemaname);
        createTableIfNotExists(schemaname, relname);
        db.schemas[schemaname].tables[relname].rules[stmt.RuleStmt.rulename] = {
          name: stmt.RuleStmt.rulename,
          query: deparse_pg_default(stmt)
        };
        continue;
      }
      throw new Error(`Unhandled stmt: "${Object.keys(stmt)[0]}"`);
    } catch (e) {
      if (!opts.ignoreErrors) {
        throw e;
      }
      console.log(e.toString());
    }
  }
  return db;
};
var get_tree_from_sql_default = getTreeFromSQL;

// src/tree-to-directory.ts
init_cjs_shims();
var import_mkdirp2 = __toESM(require("mkdirp"));
var import_rmfr = __toESM(require_rmfr());
var import_isEmpty = __toESM(require("lodash/isEmpty"));
var import_pg_formatter = require("pg-formatter");

// src/dir-structure-to-fs.ts
init_cjs_shims();
var import_mkdirp = __toESM(require("mkdirp"));
var import_promises = __toESM(require("fs/promises"));
var import_path = __toESM(require("path"));
var dirStructureToFs = async ({
  outputDir,
  dirStructure,
  header
}) => {
  for (const filePath in dirStructure) {
    const fullFilePath = import_path.default.resolve(outputDir, filePath);
    await (0, import_mkdirp.default)(import_path.default.dirname(fullFilePath));
    await import_promises.default.writeFile(fullFilePath, (header ? `-- ${header}

` : "") + dirStructure[filePath]);
  }
};

// src/tree-to-directory.ts
var section = (title, content) => {
  if (!content)
    return "";
  return `--
-- ${title}
--

${content}
`;
};
var render = (queries) => {
  if (!queries || (0, import_isEmpty.default)(queries))
    return "";
  const queriesList = Array.isArray(queries) ? queries : [queries];
  return (0, import_pg_formatter.format)(queriesList.map(({ query }) => query + ";").join("\n\n"));
};
var treeToDirectoryStructure = (db) => {
  const d = {};
  d["misc.sql"] = section("Extensions", render(db.extensions)) + section("Misc", render(db.misc));
  for (const schema of Object.values(db.schemas)) {
    for (const table of Object.values(schema.tables)) {
      d[`${schema.name}/tables/${table.name}/table.sql`] = render(table) + "\n" + render(table.alterations) + "\n" + render(Object.values(table.indexes));
      if (!(0, import_isEmpty.default)(table.triggers)) {
        d[`${schema.name}/tables/${table.name}/triggers.sql`] = render(Object.values(table.triggers));
      }
      if (!(0, import_isEmpty.default)(table.sequences)) {
        d[`${schema.name}/tables/${table.name}/sequences.sql`] = render(table.sequences) + render(table.sequences.flatMap((s) => s.grants));
      }
      if (!(0, import_isEmpty.default)(table.policies)) {
        d[`${schema.name}/tables/${table.name}/policies.sql`] = render(Object.values(table.policies));
      }
    }
    for (const view of Object.values(schema.views)) {
      d[`${schema.name}/views/${view.name}.sql`] = render(view) + "\n" + render(view.alterations) + "\n" + section("Grants", render(view.grants)) + section("Triggers", render(Object.values(view.triggers)));
      view.triggers;
    }
    for (const fn of Object.values(schema.functions)) {
      d[`${schema.name}/functions/${fn.name}.sql`] = render(fn);
    }
    if (!(0, import_isEmpty.default)(schema.grants)) {
      d[`${schema.name}/grants.sql`] = render(schema.grants);
    }
  }
  return d;
};
var treeToDirectory = async (db, outputDir, { header = "Generated by pgtui" } = {}) => {
  await (0, import_rmfr.default)(outputDir).catch((e) => {
  });
  await (0, import_mkdirp2.default)(outputDir);
  const dirStructure = treeToDirectoryStructure(db);
  await dirStructureToFs({ outputDir, dirStructure, header });
};
var tree_to_directory_default = treeToDirectory;

// src/load-structure-sql.ts
init_cjs_shims();
var import_execa = __toESM(require("execa"));
var import_pgknexlove = __toESM(require("pgknexlove"));
var import_docker_host_ip = __toESM(require("docker-host-ip"));
var loadStructureSQL = async (connectionInfo) => {
  let { host, port, user, password, database } = __spreadValues(__spreadValues({}, import_pgknexlove.default.default.getConnectionInfo()), connectionInfo);
  if (process.env.RUNNING_IN_DOCKER && !process.env.POSTGRES_HOST && !process.env.DATABASE_URL) {
    host = await new Promise((resolve, reject) => {
      (0, import_docker_host_ip.default)((err, ip) => {
        if (err)
          return reject(err);
        resolve(ip);
      });
    });
    console.log(`Detected we're in docker and no host has been set, using automatically detected host "${host}". Manually set POSTGRES_HOST or DATABASE_URL to prevent default from being overridden.`);
  }
  const result = await (0, import_execa.default)("pg_dump", ["-h", host, "-p", port, "-U", user, "-s", database].map((a) => a.toString()));
  return result.stdout;
};
var load_structure_sql_default = loadStructureSQL;

// src/tree-to-typescript-models/index.ts
init_cjs_shims();
var import_ts_morph = require("ts-morph");

// src/snake-to-pascal.ts
init_cjs_shims();
var import_lodash = require("lodash");
var snakeToPascal = (string) => {
  const camelCased = (0, import_lodash.camelCase)(string);
  return camelCased[0].toUpperCase() + camelCased.slice(1);
};
var snake_to_pascal_default = snakeToPascal;

// src/sql-to-ts-type.ts
init_cjs_shims();
var sqlToTsType = (type, canBeNull) => {
  let tsType = null;
  const typeWithoutArray = type.replace(/\[\]$/, "");
  const isTypeArray = type.endsWith("[]");
  switch (typeWithoutArray) {
    case "text":
    case "uuid":
    case "varchar":
      tsType = "string";
      break;
    case "int4":
    case "int":
      tsType = "number";
      break;
    case "jsonb":
      tsType = "any";
      break;
    case "timestamptz":
    case "timestamp":
      tsType = "Date";
      break;
    case "bool":
    case "boolean":
      tsType = "boolean";
      break;
    default:
      tsType = "any";
      break;
  }
  if (isTypeArray) {
    tsType += "[]";
  }
  if (tsType === "any") {
    return tsType;
  }
  return canBeNull ? `${tsType} | null` : tsType;
};
var sql_to_ts_type_default = sqlToTsType;

// src/tree-to-typescript-models/index.ts
var import_prettier = __toESM(require("prettier"));
var treeToTypescriptModels = (db, {
  primarySchemaName = "public",
  injectedTypesDirectory = "injected-types"
} = {}) => {
  const project = new import_ts_morph.Project({
    useInMemoryFileSystem: true
  });
  project.addSourceFilesAtPaths("**/*ts");
  const indexFile = project.createSourceFile("index.ts", "");
  indexFile.addImportDeclaration({
    moduleSpecifier: "./knex"
  });
  const isPrimarySchemaNameValid = Object.keys(db.schemas).includes(primarySchemaName);
  if (isPrimarySchemaNameValid) {
    indexFile.addExportDeclaration({
      moduleSpecifier: `./${primarySchemaName}`
    });
  }
  for (const [schemaName, schema] of Object.entries(db.schemas)) {
    if (Object.keys(schema.tables).length === 0)
      continue;
    indexFile.addExportDeclaration({
      moduleSpecifier: `./${schemaName}`,
      namespaceExport: schemaName !== "public" ? schemaName : "public_"
    });
  }
  const knexFile = project.createSourceFile("knex.ts", "");
  const prefixedKnexFileImportAliases = [];
  for (const schema of Object.values(db.schemas)) {
    const schemaName = schema.name;
    if (Object.keys(schema.tables).length === 0)
      continue;
    project.createSourceFile(`${schemaName}`, "");
    const schemaIndexFile = project.createSourceFile(`${schemaName}/index.ts`, "");
    const modelTypeMapName = "ModelTypeMap";
    const InitializerTypeMapName = "InitializerTypeMap";
    const modelTypeMapDeclaration = schemaIndexFile.addInterface({
      name: modelTypeMapName
    });
    const initializermodelTypeMapDeclaration = schemaIndexFile.addInterface({
      name: InitializerTypeMapName
    });
    const schemaIndexFileExportDeclaration = schemaIndexFile.addExportDeclaration({
      isTypeOnly: true,
      namedExports: [modelTypeMapName, InitializerTypeMapName]
    });
    const knexFileImportAlias = snake_to_pascal_default(schemaName) + modelTypeMapName;
    const prefixedKnexFileImportAlias = `Prefixed${knexFileImportAlias}`;
    prefixedKnexFileImportAliases.push(prefixedKnexFileImportAlias);
    const knexFileExportDeclaration = knexFile.insertImportDeclaration(0, {
      moduleSpecifier: `./${schemaName}`
    });
    knexFileExportDeclaration.addNamedImport({
      name: modelTypeMapName,
      alias: knexFileImportAlias
    });
    knexFile.addTypeAlias({
      name: prefixedKnexFileImportAlias,
      type: `{
[K in keyof ${knexFileImportAlias} as \`${schemaName}.\${K}\`]: ${knexFileImportAlias}[K]
}`
    });
    for (const [tableName, tableData] of Object.entries(schema.tables)) {
      const pascaledTableName = snake_to_pascal_default(tableName);
      const initializerName = `${pascaledTableName}Initializer`;
      const tableFile = project.createSourceFile(`${schemaName}/${pascaledTableName}.ts`, "");
      for (const column of tableData.columns) {
        if (column.name.endsWith("_id")) {
          const columnTypeName = snake_to_pascal_default(column.name);
          tableFile.addTypeAlias({
            name: columnTypeName,
            type: "string",
            isExported: true
          });
        }
      }
      const tableInterfaceDeclaration = tableFile.addInterface({
        name: pascaledTableName,
        isDefaultExport: true
      });
      const tableInterfaceInitializerDeclaration = tableFile.addInterface({
        name: initializerName,
        isExported: true
      });
      for (const column of tableData.columns) {
        const propertyCanBeNull = !column.query.includes("NOT NULL");
        const propertyHasDefaultValue = column.query.includes("DEFAULT");
        const isPropertyOptional = propertyHasDefaultValue || propertyCanBeNull;
        let tsType = sql_to_ts_type_default(column.type, propertyCanBeNull);
        if (column.name.endsWith("_id"))
          tsType = snake_to_pascal_default(column.name);
        const injectedTypeComment = column.comments.find((comment) => comment.comment.includes("@type:"));
        if (injectedTypeComment) {
          const typeToInject = injectedTypeComment.comment.split("@type:")[1].trim();
          tsType = typeToInject;
          tableFile.insertImportDeclaration(0, {
            moduleSpecifier: `${injectedTypesDirectory}/${typeToInject}`,
            defaultImport: typeToInject
          });
        }
        tableInterfaceDeclaration.addProperty({
          name: column.name,
          type: tsType
        });
        tableInterfaceInitializerDeclaration.addProperty({
          name: column.name,
          type: tsType,
          hasQuestionToken: isPropertyOptional
        });
      }
      const interfaceImportDeclaration = schemaIndexFile.addImportDeclaration({
        moduleSpecifier: `./${pascaledTableName}`,
        defaultImport: pascaledTableName
      });
      interfaceImportDeclaration.addNamedImport({
        name: initializerName
      });
      modelTypeMapDeclaration.addProperty({
        name: tableName,
        type: pascaledTableName
      });
      initializermodelTypeMapDeclaration.addProperty({
        name: tableName,
        type: initializerName
      });
      schemaIndexFileExportDeclaration.addNamedExports([
        pascaledTableName,
        initializerName
      ]);
      tableFile.saveSync();
    }
    schemaIndexFile.saveSync();
  }
  const moduleDeclaration = knexFile.addModule({
    name: '"knex/types/tables"',
    hasDeclareKeyword: true,
    declarationKind: import_ts_morph.ModuleDeclarationKind.Module
  });
  moduleDeclaration.addInterface({
    name: "Tables",
    extends: isPrimarySchemaNameValid ? [snake_to_pascal_default(primarySchemaName) + "ModelTypeMap"] : ["PublicModelTypeMap"]
  });
  const addInterfaceTemplates = prefixedKnexFileImportAliases.map((alias) => ({
    name: "Tables",
    extends: alias
  }));
  moduleDeclaration.addInterfaces(addInterfaceTemplates);
  indexFile.saveSync();
  knexFile.saveSync();
  const filePaths = project.getFileSystem().globSync(["**/*.ts"]);
  const fsObj = {};
  for (const filePath of filePaths) {
    fsObj[`.${filePath}`] = import_prettier.default.format(project.getFileSystem().readFileSync(filePath), {
      semi: false,
      parser: "typescript"
    });
  }
  return fsObj;
};
var tree_to_typescript_models_default = treeToTypescriptModels;

// src/cli.ts
var argv = (0, import_yargs.default)((0, import_helpers.hideBin)(process.argv)).command("dump-structure", "Dump database structure into file", (yargs2) => yargs2.positional("fileName", {
  describe: "File name to dump to"
}).options({
  json: {
    boolean: true,
    desc: "Dump as JSON"
  }
})).command("dump-to-dir", "Dump database structure into directory", (yargs2) => yargs2.positional("dir", {
  describe: "Target Directory to dump to (will be deleted/recreated)"
}).options({
  header: {
    desc: "Header at top of generated sql files",
    default: "Generated by pgtui"
  },
  sqlFile: {
    desc: "Load SQL File as Schema"
  }
})).command("dump-typescript-models", "Dump typescript structure into directory", (yargs2) => yargs2.positional("dir", {
  describe: "Target Directory to dump to (will be deleted/recreated)"
}).options({
  header: {
    desc: "Header at top of generated sql files",
    default: "Generated by pgtui"
  },
  sqlFile: {
    desc: "Load SQL File as Schema"
  },
  defaultSchema: {
    desc: "Set default schema"
  },
  injectedTypesDirectory: {
    desc: "Directory where injected types are stored"
  }
})).options({
  host: { desc: "Postgres Host", alias: "h" },
  password: { desc: "Postgres Password" },
  user: { desc: "Postgres User", alias: "U" },
  port: { desc: "Postgres Port", alias: "p" },
  database: { desc: "Postgres Database", alias: "W" },
  ignoreErrors: { desc: "Ignore errors while parsing schema" }
}).showHelpOnFail(true).demandCommand().argv;
var commandMap = {
  "dump-structure": async (argv2) => {
    const [, fileName] = argv2._;
    const content = await load_structure_sql_default(argv2);
    if (argv2.json) {
      const jsonContent = get_tree_from_sql_default(content, {
        ignoreErrors: argv2.ignoreErrors
      });
      await import_promises2.default.writeFile(fileName, JSON.stringify(jsonContent, null, "  "));
    } else {
      await import_promises2.default.writeFile(fileName, content);
    }
  },
  "dump-to-dir": async (argv2) => {
    const [, targetDir] = argv2._;
    let content;
    if (argv2.sqlFile) {
      content = (await import_promises2.default.readFile(argv2.sqlFile)).toString();
    } else {
      content = await load_structure_sql_default(argv2);
    }
    await tree_to_directory_default(get_tree_from_sql_default(content, {
      ignoreErrors: argv2.ignoreErrors
    }), targetDir, argv2);
  },
  "dump-typescript-models": async (argv2) => {
    const [, targetDir] = argv2._;
    let content;
    if (argv2.sqlFile) {
      content = (await import_promises2.default.readFile(argv2.sqlFile)).toString();
    } else {
      content = await load_structure_sql_default(argv2);
    }
    const dirStructure = await tree_to_typescript_models_default(get_tree_from_sql_default(content, {
      ignoreErrors: argv2.ignoreErrors
    }), {
      primarySchemaName: argv2.defaultSchema,
      injectedTypesDirectory: argv2.injectedTypesDirectory
    });
    await dirStructureToFs({ dirStructure, outputDir: targetDir });
  }
};
async function main() {
  const [cmd] = (await argv)._;
  if (!commandMap[cmd])
    throw new Error(`Command not found "${cmd}"`);
  await commandMap[cmd](argv);
}
main().catch((e) => {
  console.log(e.stack);
});
/*!
 * array-to-sentence | MIT (c) Shinnosuke Watanabe
 * https://github.com/shinnn/array-to-sentence
*/
/*!
 * assert-valid-glob-opts | MIT (c) Shinnosuke Watanabe
 * https://github.com/shinnn/assert-valid-glob-opts
*/
/*!
 * glob-option-error | MIT (c) Shinnosuke Watanabe
 * https://github.com/shinnn/glob-option-error
*/
/*!
 * indexed-filter | MIT (c) Shinnosuke Watanabe
 * https://github.com/shinnn/indexed-filter
*/
//# sourceMappingURL=cli.js.map