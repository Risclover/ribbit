var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/get-tree-from-sql.ts
var get_tree_from_sql_exports = {};
__export(get_tree_from_sql_exports, {
  default: () => get_tree_from_sql_default,
  getTreeFromSQL: () => getTreeFromSQL
});
module.exports = __toCommonJS(get_tree_from_sql_exports);
var pgParser2 = __toESM(require("pgsql-parser"));

// src/deparse-pg.ts
var pgParser = __toESM(require("pgsql-parser"));
var deparsePg = (exp) => {
  if ("DefElem" in exp) {
    if (exp.DefElem.defname === "owned_by") {
      return `OWNED BY ${"List" in exp.DefElem.arg ? exp.DefElem.arg.List.items.map(deparsePg).join(".") : deparsePg(exp.DefElem.arg)}`;
    } else {
      throw new Error(`Unsupported DefElem: ${JSON.stringify(exp)}`);
    }
  }
  if ("String" in exp) {
    return exp.String.str;
  }
  if ("AlterSeqStmt" in exp) {
    const { sequence, options } = exp.AlterSeqStmt;
    console.log({
      sequence: ``,
      options: options.map(deparsePg)
    });
    return `ALTER SEQUENCE ${sequence.schemaname}.${sequence.relname} ${options.map(deparsePg).join(" ")}`;
  }
  return pgParser.deparse(exp);
};
var deparse_pg_default = deparsePg;

// src/get-tree-from-sql.ts
var getTreeFromSQL = (content, opts = {}) => {
  var _a, _b, _c, _d;
  const statements = pgParser2.parse(content).map((s) => s.RawStmt.stmt);
  const db = {
    schemas: {},
    extensions: [],
    misc: []
  };
  const unassignedSequences = [];
  function createSchemaIfNotExists(schemaname) {
    if (!db.schemas[schemaname])
      db.schemas[schemaname] = {
        name: schemaname,
        tables: {},
        views: {},
        functions: {},
        domains: {},
        grants: [],
        _tablelessSequences: {},
        owner: ""
      };
  }
  function createTableIfNotExists(schemaname, tablename) {
    const schema = db.schemas[schemaname];
    if (!schema.tables[tablename])
      schema.tables[tablename] = {
        name: tablename,
        columns: [],
        indexes: {},
        triggers: {},
        grants: [],
        owner: "",
        sequences: [],
        query: "",
        policies: {},
        rules: {},
        alterations: []
      };
  }
  function findSequence(schemaname, sequencename) {
    const schema = db.schemas[schemaname];
    if (schema._tablelessSequences[sequencename])
      return schema._tablelessSequences[sequencename];
    for (const tableName in schema.tables) {
      const table = schema.tables[tableName];
      const seq = table.sequences.find((s) => s.name === sequencename);
      if (seq)
        return seq;
    }
    throw new Error(`Couldn't find sequence: ${schemaname}.${sequencename}`);
  }
  for (const stmt of statements) {
    try {
      if ("CreateSchemaStmt" in stmt) {
        createSchemaIfNotExists(stmt.CreateSchemaStmt.schemaname);
        continue;
      }
      if ("AlterOwnerStmt" in stmt) {
        const { objectType, object, newowner } = stmt.AlterOwnerStmt;
        const targets = object.List ? object.List.items.map((item) => deparse_pg_default(item)) : [deparse_pg_default(object)];
        const targetName = targets[0];
        if (objectType === "OBJECT_SCHEMA") {
          createSchemaIfNotExists(targetName);
          db.schemas[targetName].owner = newowner.rolename;
        } else if (objectType === "OBJECT_FUNCTION") {
          const [schemaname, funcname_raw] = targetName.split(".");
          const funcname = funcname_raw.split("(")[0].trim();
          db.schemas[schemaname].functions[funcname].owner = newowner.rolename;
        } else if (objectType === "OBJECT_DOMAIN") {
          if (targetName.includes("\n")) {
            const [schema, domainname] = targetName.split("\n").map((t) => t.trim()).filter((t) => t.length > 0);
            db.schemas[schema].domains[domainname].owner = newowner.rolename;
          } else {
            const schema = targetName;
            const domainname = targets[1];
            db.schemas[schema].domains[domainname].owner = newowner.rolename;
          }
        } else {
          throw new Error(`Unsupported object type in AlterOwnerStmt: ${objectType}`);
        }
        continue;
      }
      if ("AlterSeqStmt" in stmt) {
        const { sequence, options } = stmt.AlterSeqStmt;
        const ownedByDef = options.find((o) => o.DefElem.defname === "owned_by");
        if (!ownedByDef)
          throw new Error("Only ownernership change alter sequences are implemented");
        const newowner = "List" in ownedByDef.DefElem.arg ? ownedByDef.DefElem.arg.List.items.map(deparse_pg_default).join(".") : deparse_pg_default(ownedByDef.DefElem.arg);
        const seq = findSequence(sequence.schemaname, sequence.relname);
        if (seq.owner)
          throw new Error("Sequence owner has been set more than once (not implemented)");
        seq.owner = newowner;
        delete db.schemas[sequence.schemaname]._tablelessSequences[sequence.relname];
        const [, ownerTableName] = newowner.split(".");
        db.schemas[sequence.schemaname].tables[ownerTableName].sequences.push(seq);
        continue;
      }
      if ("CreateStmt" in stmt) {
        const { schemaname, relname } = stmt.CreateStmt.relation;
        const table = {
          name: relname,
          columns: stmt.CreateStmt.tableElts.filter((a) => "ColumnDef" in a).map((a) => {
            const { colname, typeName } = a.ColumnDef;
            let type = typeName.names.map(deparse_pg_default).pop();
            if (typeName.arrayBounds) {
              type += "[]";
            }
            return { name: colname, type, query: deparse_pg_default(a), comments: [] };
          }),
          query: deparse_pg_default(stmt),
          alterations: [],
          policies: {},
          triggers: {},
          rules: {},
          indexes: {},
          sequences: [],
          grants: [],
          owner: ""
        };
        createSchemaIfNotExists(schemaname);
        createTableIfNotExists(schemaname, relname);
        db.schemas[schemaname].tables[relname] = __spreadValues(__spreadValues({}, db.schemas[schemaname].tables[relname]), table);
        continue;
      }
      if ("CreateFunctionStmt" in stmt) {
        const {
          funcname: fullFuncName,
          returnType,
          options
        } = stmt.CreateFunctionStmt;
        const [schemaname, funcname] = deparse_pg_default(fullFuncName).replace("\n\n", ".").split(".");
        createSchemaIfNotExists(schemaname);
        db.schemas[schemaname].functions[funcname] = {
          name: funcname,
          query: deparse_pg_default(stmt),
          owner: ""
        };
        continue;
      }
      if ("CreateTrigStmt" in stmt) {
        const {
          relation: { schemaname, relname },
          trigname,
          funcname,
          row,
          timing,
          events
        } = stmt.CreateTrigStmt;
        db.schemas[schemaname].tables[relname].triggers[trigname] = {
          name: trigname,
          functionName: deparse_pg_default(funcname),
          query: deparse_pg_default(stmt)
        };
        continue;
      }
      if ("CreatePolicyStmt" in stmt) {
        const { policy_name, table, cmd_name, permissive, roles, qual } = stmt.CreatePolicyStmt;
        db.schemas[table.schemaname].tables[table.relname].policies[policy_name] = {
          name: policy_name,
          query: deparse_pg_default(stmt)
        };
        continue;
      }
      if ("ViewStmt" in stmt) {
        const { view, query } = stmt.ViewStmt;
        createSchemaIfNotExists(view.schemaname);
        db.schemas[view.schemaname].views[view.relname] = {
          name: view.relname,
          columns: [],
          grants: [],
          triggers: {},
          alterations: [],
          query: deparse_pg_default(query),
          owner: ""
        };
        continue;
      }
      if ("CreateSeqStmt" in stmt) {
        const { schemaname, relname } = stmt.CreateSeqStmt.sequence;
        createSchemaIfNotExists(schemaname);
        db.schemas[schemaname]._tablelessSequences[relname] = {
          name: relname,
          grants: [],
          alterations: [],
          owner: "",
          query: deparse_pg_default(stmt)
        };
        continue;
      }
      if ("AlterTableStmt" in stmt) {
        const { schemaname, relname } = stmt.AlterTableStmt.relation;
        createSchemaIfNotExists(schemaname);
        createTableIfNotExists(schemaname, relname);
        const target = db.schemas[schemaname].tables[relname] || db.schemas[schemaname].views[relname] || db.schemas[schemaname]._tablelessSequences[relname];
        try {
          target.alterations.push({
            query: deparse_pg_default(stmt)
          });
        } catch (error) {
        }
        continue;
      }
      if ("GrantStmt" in stmt) {
        const { is_grant, targtype, objtype, objects, grantees } = stmt.GrantStmt;
        const targetName = deparse_pg_default(objects);
        if (objtype === "OBJECT_SCHEMA") {
          (_a = db.schemas[targetName]) == null ? void 0 : _a.grants.push({
            query: deparse_pg_default(stmt)
          });
        } else if (objtype === "OBJECT_TABLE") {
          const [schemaname, tablename] = targetName.split(".");
          const target = (_d = (_b = db.schemas[schemaname]) == null ? void 0 : _b.tables[tablename]) != null ? _d : (_c = db.schemas[schemaname]) == null ? void 0 : _c.views[tablename];
          target == null ? void 0 : target.grants.push({
            query: deparse_pg_default(stmt)
          });
        } else if (objtype === "OBJECT_SEQUENCE") {
          const [schemaname, seqname] = targetName.split(".");
          findSequence(schemaname, seqname).grants.push({
            query: deparse_pg_default(stmt)
          });
        } else {
          throw new Error(`Unhandled objtype in GrantStmt: "${objtype}"`);
        }
        continue;
      }
      if ("CreateExtensionStmt" in stmt) {
        db.extensions.push({
          query: deparse_pg_default(stmt),
          name: stmt.CreateExtensionStmt.extname
        });
        continue;
      }
      if ("IndexStmt" in stmt) {
        const { idxname, relation } = stmt.IndexStmt;
        db.schemas[relation.schemaname].tables[relation.relname].indexes[idxname] = {
          name: idxname,
          query: deparse_pg_default(stmt)
        };
        continue;
      }
      if ("VariableSetStmt" in stmt || "SelectStmt" in stmt || "CompositeTypeStmt" in stmt) {
        db.misc.push({ query: deparse_pg_default(stmt) });
        continue;
      }
      if ("CommentStmt" in stmt) {
        if (stmt.CommentStmt.objtype === "OBJECT_COLUMN") {
          try {
            const [schema, table, columnName] = stmt.CommentStmt.object.List.items.map((item) => item.String.str);
            const column = db.schemas[schema].tables[table].columns.find((col) => col.name === columnName);
            column.comments.push({
              comment: stmt.CommentStmt.comment,
              query: deparse_pg_default(stmt)
            });
          } catch (e) {
            db.misc.push({ query: deparse_pg_default(stmt) });
          }
        } else {
          db.misc.push({ query: deparse_pg_default(stmt) });
        }
        continue;
      }
      if ("CreateDomainStmt" in stmt) {
        const [schemaname, domainname] = deparse_pg_default(stmt.CreateDomainStmt.domainname).replace("\n\n", ".").split(".");
        if (typeof domainname === "undefined") {
          continue;
        }
        createSchemaIfNotExists(schemaname);
        db.schemas[schemaname].domains[domainname] = {
          name: domainname,
          type: deparse_pg_default(stmt.CreateDomainStmt.typeName.names),
          owner: ""
        };
        continue;
      }
      if ("RuleStmt" in stmt) {
        const schemaname = stmt.RuleStmt.relation.schemaname;
        const relname = stmt.RuleStmt.relation.relname;
        createSchemaIfNotExists(schemaname);
        createTableIfNotExists(schemaname, relname);
        db.schemas[schemaname].tables[relname].rules[stmt.RuleStmt.rulename] = {
          name: stmt.RuleStmt.rulename,
          query: deparse_pg_default(stmt)
        };
        continue;
      }
      throw new Error(`Unhandled stmt: "${Object.keys(stmt)[0]}"`);
    } catch (e) {
      if (!opts.ignoreErrors) {
        throw e;
      }
      console.log(e.toString());
    }
  }
  return db;
};
var get_tree_from_sql_default = getTreeFromSQL;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  getTreeFromSQL
});
//# sourceMappingURL=get-tree-from-sql.js.map