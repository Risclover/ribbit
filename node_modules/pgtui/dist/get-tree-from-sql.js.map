{"version":3,"sources":["../src/get-tree-from-sql.ts","../src/deparse-pg.ts"],"sourcesContent":["import { DatabaseTree, Table } from \"./types/tree\"\nimport { pg } from \"./types\"\nimport * as pgParser from \"pgsql-parser\"\nimport fs from \"fs\"\nimport path from \"path\"\nimport deparsePg from \"./deparse-pg\"\n\nexport const getTreeFromSQL = (\n  content: string,\n  opts: { ignoreErrors?: boolean } = {}\n): DatabaseTree => {\n  const statements: Array<pg.Statement> = pgParser\n    .parse(content)\n    .map((s) => s.RawStmt.stmt)\n\n  const db: DatabaseTree = {\n    schemas: {},\n    extensions: [],\n    misc: [],\n  }\n\n  const unassignedSequences = []\n\n  function createSchemaIfNotExists(schemaname: string) {\n    if (!db.schemas[schemaname])\n      db.schemas[schemaname] = {\n        name: schemaname,\n        tables: {},\n        views: {},\n        functions: {},\n        domains: {},\n        grants: [],\n        _tablelessSequences: {},\n        owner: \"\",\n      }\n  }\n\n  function createTableIfNotExists(schemaname: string, tablename: string) {\n    const schema = db.schemas[schemaname]\n    if (!schema.tables[tablename])\n      schema.tables[tablename] = {\n        name: tablename,\n        columns: [],\n        indexes: {},\n        triggers: {},\n        grants: [],\n        owner: \"\",\n        sequences: [],\n        query: \"\",\n        policies: {},\n        rules: {},\n        alterations: [],\n      }\n  }\n\n  function findSequence(schemaname: string, sequencename: string) {\n    const schema = db.schemas[schemaname]\n    if (schema._tablelessSequences[sequencename])\n      return schema._tablelessSequences[sequencename]\n    for (const tableName in schema.tables) {\n      const table = schema.tables[tableName]\n      const seq = table.sequences.find((s) => s.name === sequencename)\n      if (seq) return seq\n    }\n    throw new Error(`Couldn't find sequence: ${schemaname}.${sequencename}`)\n  }\n\n  for (const stmt of statements) {\n    try {\n      if (\"CreateSchemaStmt\" in stmt) {\n        createSchemaIfNotExists(stmt.CreateSchemaStmt.schemaname)\n        continue\n      }\n\n      if (\"AlterOwnerStmt\" in stmt) {\n        const { objectType, object, newowner } = stmt.AlterOwnerStmt\n        const targets = (object as any).List\n          ? (object as any).List.items.map((item) => deparsePg(item))\n          : [deparsePg(object)]\n\n        const targetName = targets[0]\n        if (objectType === \"OBJECT_SCHEMA\") {\n          createSchemaIfNotExists(targetName)\n          db.schemas[targetName].owner = newowner.rolename\n        } else if (objectType === \"OBJECT_FUNCTION\") {\n          const [schemaname, funcname_raw] = targetName.split(\".\")\n          const funcname = funcname_raw.split(\"(\")[0].trim()\n          db.schemas[schemaname].functions[funcname].owner = newowner.rolename\n        } else if (objectType === \"OBJECT_DOMAIN\") {\n          if (targetName.includes(\"\\n\")) {\n            const [schema, domainname] = targetName\n              .split(\"\\n\")\n              .map((t) => t.trim())\n              .filter((t) => t.length > 0)\n            db.schemas[schema].domains[domainname].owner = newowner.rolename\n          } else {\n            const schema = targetName\n            const domainname = targets[1]\n\n            db.schemas[schema].domains[domainname].owner = newowner.rolename\n          }\n        } else {\n          throw new Error(\n            `Unsupported object type in AlterOwnerStmt: ${objectType}`\n          )\n        }\n        continue\n      }\n\n      if (\"AlterSeqStmt\" in stmt) {\n        const { sequence, options } = stmt.AlterSeqStmt\n        const ownedByDef = options.find((o) => o.DefElem.defname === \"owned_by\")\n        if (!ownedByDef)\n          throw new Error(\n            \"Only ownernership change alter sequences are implemented\"\n          )\n        const newowner =\n          \"List\" in ownedByDef.DefElem.arg\n            ? ownedByDef.DefElem.arg.List.items.map(deparsePg).join(\".\")\n            : deparsePg(ownedByDef.DefElem.arg)\n\n        const seq = findSequence(sequence.schemaname, sequence.relname)\n\n        if (seq.owner)\n          throw new Error(\n            \"Sequence owner has been set more than once (not implemented)\"\n          )\n\n        seq.owner = newowner\n\n        delete db.schemas[sequence.schemaname]._tablelessSequences[\n          sequence.relname\n        ]\n\n        const [, ownerTableName] = newowner.split(\".\")\n\n        db.schemas[sequence.schemaname].tables[ownerTableName].sequences.push(\n          seq\n        )\n\n        continue\n      }\n\n      if (\"CreateStmt\" in stmt) {\n        const { schemaname, relname } = stmt.CreateStmt.relation\n        const table: Table = {\n          name: relname,\n          columns: stmt.CreateStmt.tableElts\n            .filter((a) => \"ColumnDef\" in a)\n            .map((a) => {\n              const { colname, typeName } = a.ColumnDef\n              let type = typeName.names.map(deparsePg).pop() as string\n              if ((typeName as any).arrayBounds) {\n                type += \"[]\"\n              }\n              // if (colname === \"accepted_providers\" || type === \"text\") {\n              //   console.dir(a, { depth: null })\n              // }\n              return { name: colname, type, query: deparsePg(a), comments: [] }\n            }),\n          query: deparsePg(stmt),\n          alterations: [],\n          policies: {},\n          triggers: {},\n          rules: {},\n          indexes: {},\n          sequences: [],\n          grants: [],\n          owner: \"\",\n        }\n        createSchemaIfNotExists(schemaname)\n        createTableIfNotExists(schemaname, relname)\n        db.schemas[schemaname].tables[relname] = {\n          ...db.schemas[schemaname].tables[relname],\n          ...table,\n        }\n        continue\n      }\n\n      if (\"CreateFunctionStmt\" in stmt) {\n        const {\n          funcname: fullFuncName,\n          returnType,\n          options,\n        } = stmt.CreateFunctionStmt\n        const [schemaname, funcname] = deparsePg(fullFuncName)\n          // TODO this replace may be due to a pgsql-parser bug, PR to fix it\n          .replace(\"\\n\\n\", \".\")\n          .split(\".\")\n        createSchemaIfNotExists(schemaname)\n        db.schemas[schemaname].functions[funcname] = {\n          name: funcname,\n          query: deparsePg(stmt),\n          owner: \"\",\n        }\n        continue\n      }\n\n      if (\"CreateTrigStmt\" in stmt) {\n        const {\n          relation: { schemaname, relname },\n          trigname,\n          funcname,\n          row,\n          timing,\n          events,\n        } = stmt.CreateTrigStmt\n\n        db.schemas[schemaname].tables[relname].triggers[trigname] = {\n          name: trigname,\n          functionName: deparsePg(funcname),\n          query: deparsePg(stmt),\n        }\n        continue\n      }\n\n      if (\"CreatePolicyStmt\" in stmt) {\n        const { policy_name, table, cmd_name, permissive, roles, qual } =\n          stmt.CreatePolicyStmt\n\n        db.schemas[table.schemaname].tables[table.relname].policies[\n          policy_name\n        ] = {\n          name: policy_name,\n          query: deparsePg(stmt),\n        }\n\n        continue\n      }\n\n      if (\"ViewStmt\" in stmt) {\n        const { view, query } = stmt.ViewStmt\n        createSchemaIfNotExists(view.schemaname)\n        db.schemas[view.schemaname].views[view.relname] = {\n          name: view.relname,\n          columns: [],\n          grants: [],\n          triggers: {},\n          alterations: [],\n          query: deparsePg(query),\n          owner: \"\",\n        }\n        continue\n      }\n\n      if (\"CreateSeqStmt\" in stmt) {\n        const { schemaname, relname } = stmt.CreateSeqStmt.sequence\n        createSchemaIfNotExists(schemaname)\n        db.schemas[schemaname]._tablelessSequences[relname] = {\n          name: relname,\n          grants: [],\n          alterations: [],\n          owner: \"\",\n          query: deparsePg(stmt),\n        }\n        continue\n      }\n\n      if (\"AlterTableStmt\" in stmt) {\n        const { schemaname, relname } = stmt.AlterTableStmt.relation\n        createSchemaIfNotExists(schemaname)\n        createTableIfNotExists(schemaname, relname)\n\n        const target =\n          db.schemas[schemaname].tables[relname] ||\n          db.schemas[schemaname].views[relname] ||\n          db.schemas[schemaname]._tablelessSequences[relname]\n\n        try {\n          target.alterations.push({\n            query: deparsePg(stmt),\n          })\n        } catch (error) {}\n\n        continue\n      }\n\n      if (\"GrantStmt\" in stmt) {\n        const { is_grant, targtype, objtype, objects, grantees } =\n          stmt.GrantStmt\n        const targetName = deparsePg(objects)\n        if (objtype === \"OBJECT_SCHEMA\") {\n          db.schemas[targetName]?.grants.push({\n            query: deparsePg(stmt),\n          })\n        } else if (objtype === \"OBJECT_TABLE\") {\n          const [schemaname, tablename] = targetName.split(\".\")\n          const target =\n            db.schemas[schemaname]?.tables[tablename] ??\n            db.schemas[schemaname]?.views[tablename]\n\n          target?.grants.push({\n            query: deparsePg(stmt),\n          })\n        } else if (objtype === \"OBJECT_SEQUENCE\") {\n          const [schemaname, seqname] = targetName.split(\".\")\n          findSequence(schemaname, seqname).grants.push({\n            query: deparsePg(stmt),\n          })\n        } else {\n          throw new Error(`Unhandled objtype in GrantStmt: \"${objtype}\"`)\n        }\n        continue\n      }\n\n      if (\"CreateExtensionStmt\" in stmt) {\n        db.extensions.push({\n          query: deparsePg(stmt),\n          name: stmt.CreateExtensionStmt.extname,\n        })\n        continue\n      }\n\n      if (\"IndexStmt\" in stmt) {\n        const { idxname, relation } = stmt.IndexStmt\n        db.schemas[relation.schemaname].tables[relation.relname].indexes[\n          idxname\n        ] = {\n          name: idxname,\n          query: deparsePg(stmt),\n        }\n        continue\n      }\n\n      if (\n        \"VariableSetStmt\" in stmt ||\n        \"SelectStmt\" in stmt ||\n        \"CompositeTypeStmt\" in stmt\n      ) {\n        db.misc.push({ query: deparsePg(stmt) })\n        continue\n      }\n\n      if (\"CommentStmt\" in stmt) {\n        if ((stmt.CommentStmt.objtype as string) === \"OBJECT_COLUMN\") {\n          try {\n            const [schema, table, columnName] = (\n              stmt as any\n            ).CommentStmt.object.List.items.map((item) => item.String.str)\n            const column = db.schemas[schema].tables[table].columns.find(\n              (col) => col.name === columnName\n            )\n            column.comments.push({\n              comment: stmt.CommentStmt.comment,\n              query: deparsePg(stmt),\n            })\n          } catch (e) {\n            db.misc.push({ query: deparsePg(stmt) })\n          }\n        } else {\n          db.misc.push({ query: deparsePg(stmt) })\n        }\n        continue\n      }\n\n      if (\"CreateDomainStmt\" in stmt) {\n        const [schemaname, domainname] = deparsePg(\n          stmt.CreateDomainStmt.domainname\n        )\n          // TODO this replace may be due to a pgsql-parser bug, PR to fix it\n          .replace(\"\\n\\n\", \".\")\n          .split(\".\")\n\n        if (typeof domainname === \"undefined\") {\n          continue\n        }\n\n        createSchemaIfNotExists(schemaname)\n        db.schemas[schemaname].domains[domainname] = {\n          name: domainname,\n          type: deparsePg(stmt.CreateDomainStmt.typeName.names),\n          owner: \"\",\n        }\n\n        continue\n      }\n\n      if (\"RuleStmt\" in stmt) {\n        const schemaname = stmt.RuleStmt.relation.schemaname\n        const relname = stmt.RuleStmt.relation.relname\n\n        createSchemaIfNotExists(schemaname)\n        createTableIfNotExists(schemaname, relname)\n\n        db.schemas[schemaname].tables[relname].rules[stmt.RuleStmt.rulename] = {\n          name: stmt.RuleStmt.rulename,\n          query: deparsePg(stmt),\n        }\n\n        continue\n      }\n\n      throw new Error(`Unhandled stmt: \"${Object.keys(stmt)[0]}\"`)\n    } catch (e) {\n      if (!opts.ignoreErrors) {\n        throw e\n      }\n      console.log(e.toString())\n    }\n  }\n\n  return db\n}\n\nexport default getTreeFromSQL\n","import * as pgParser from \"pgsql-parser\"\nimport { pg } from \"./types/pg\"\n\nexport const deparsePg = (exp: pg.Statement | pg.Expression) => {\n  if (\"DefElem\" in exp) {\n    if (exp.DefElem.defname === \"owned_by\") {\n      return `OWNED BY ${\n        \"List\" in exp.DefElem.arg\n          ? exp.DefElem.arg.List.items.map(deparsePg).join(\".\")\n          : deparsePg(exp.DefElem.arg)\n      }`\n    } else {\n      throw new Error(`Unsupported DefElem: ${JSON.stringify(exp)}`)\n    }\n  }\n  if (\"String\" in exp) {\n    return exp.String.str\n  }\n  if (\"AlterSeqStmt\" in exp) {\n    const { sequence, options } = exp.AlterSeqStmt\n    console.log({\n      // sequence: deparsePg(sequence),\n      sequence: ``,\n      options: options.map(deparsePg),\n    })\n    return `ALTER SEQUENCE ${sequence.schemaname}.${sequence.relname} ${options\n      .map(deparsePg)\n      .join(\" \")}`\n  }\n  return pgParser.deparse(exp)\n}\n\nexport default deparsePg\n"],"mappings":"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","names":[]}