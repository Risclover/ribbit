var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/tree-to-typescript-models/index.ts
var tree_to_typescript_models_exports = {};
__export(tree_to_typescript_models_exports, {
  default: () => tree_to_typescript_models_default,
  treeToTypescriptModels: () => treeToTypescriptModels
});
module.exports = __toCommonJS(tree_to_typescript_models_exports);
var import_ts_morph = require("ts-morph");

// src/snake-to-pascal.ts
var import_lodash = require("lodash");
var snakeToPascal = (string) => {
  const camelCased = (0, import_lodash.camelCase)(string);
  return camelCased[0].toUpperCase() + camelCased.slice(1);
};
var snake_to_pascal_default = snakeToPascal;

// src/sql-to-ts-type.ts
var sqlToTsType = (type, canBeNull) => {
  let tsType = null;
  const typeWithoutArray = type.replace(/\[\]$/, "");
  const isTypeArray = type.endsWith("[]");
  switch (typeWithoutArray) {
    case "text":
    case "uuid":
    case "varchar":
      tsType = "string";
      break;
    case "int4":
    case "int":
      tsType = "number";
      break;
    case "jsonb":
      tsType = "any";
      break;
    case "timestamptz":
    case "timestamp":
      tsType = "Date";
      break;
    case "bool":
    case "boolean":
      tsType = "boolean";
      break;
    default:
      tsType = "any";
      break;
  }
  if (isTypeArray) {
    tsType += "[]";
  }
  if (tsType === "any") {
    return tsType;
  }
  return canBeNull ? `${tsType} | null` : tsType;
};
var sql_to_ts_type_default = sqlToTsType;

// src/tree-to-typescript-models/index.ts
var import_prettier = __toESM(require("prettier"));
var treeToTypescriptModels = (db, {
  primarySchemaName = "public",
  injectedTypesDirectory = "injected-types"
} = {}) => {
  const project = new import_ts_morph.Project({
    useInMemoryFileSystem: true
  });
  project.addSourceFilesAtPaths("**/*ts");
  const indexFile = project.createSourceFile("index.ts", "");
  indexFile.addImportDeclaration({
    moduleSpecifier: "./knex"
  });
  const isPrimarySchemaNameValid = Object.keys(db.schemas).includes(primarySchemaName);
  if (isPrimarySchemaNameValid) {
    indexFile.addExportDeclaration({
      moduleSpecifier: `./${primarySchemaName}`
    });
  }
  for (const [schemaName, schema] of Object.entries(db.schemas)) {
    if (Object.keys(schema.tables).length === 0)
      continue;
    indexFile.addExportDeclaration({
      moduleSpecifier: `./${schemaName}`,
      namespaceExport: schemaName !== "public" ? schemaName : "public_"
    });
  }
  const knexFile = project.createSourceFile("knex.ts", "");
  const prefixedKnexFileImportAliases = [];
  for (const schema of Object.values(db.schemas)) {
    const schemaName = schema.name;
    if (Object.keys(schema.tables).length === 0)
      continue;
    project.createSourceFile(`${schemaName}`, "");
    const schemaIndexFile = project.createSourceFile(`${schemaName}/index.ts`, "");
    const modelTypeMapName = "ModelTypeMap";
    const InitializerTypeMapName = "InitializerTypeMap";
    const modelTypeMapDeclaration = schemaIndexFile.addInterface({
      name: modelTypeMapName
    });
    const initializermodelTypeMapDeclaration = schemaIndexFile.addInterface({
      name: InitializerTypeMapName
    });
    const schemaIndexFileExportDeclaration = schemaIndexFile.addExportDeclaration({
      isTypeOnly: true,
      namedExports: [modelTypeMapName, InitializerTypeMapName]
    });
    const knexFileImportAlias = snake_to_pascal_default(schemaName) + modelTypeMapName;
    const prefixedKnexFileImportAlias = `Prefixed${knexFileImportAlias}`;
    prefixedKnexFileImportAliases.push(prefixedKnexFileImportAlias);
    const knexFileExportDeclaration = knexFile.insertImportDeclaration(0, {
      moduleSpecifier: `./${schemaName}`
    });
    knexFileExportDeclaration.addNamedImport({
      name: modelTypeMapName,
      alias: knexFileImportAlias
    });
    knexFile.addTypeAlias({
      name: prefixedKnexFileImportAlias,
      type: `{
[K in keyof ${knexFileImportAlias} as \`${schemaName}.\${K}\`]: ${knexFileImportAlias}[K]
}`
    });
    for (const [tableName, tableData] of Object.entries(schema.tables)) {
      const pascaledTableName = snake_to_pascal_default(tableName);
      const initializerName = `${pascaledTableName}Initializer`;
      const tableFile = project.createSourceFile(`${schemaName}/${pascaledTableName}.ts`, "");
      for (const column of tableData.columns) {
        if (column.name.endsWith("_id")) {
          const columnTypeName = snake_to_pascal_default(column.name);
          tableFile.addTypeAlias({
            name: columnTypeName,
            type: "string",
            isExported: true
          });
        }
      }
      const tableInterfaceDeclaration = tableFile.addInterface({
        name: pascaledTableName,
        isDefaultExport: true
      });
      const tableInterfaceInitializerDeclaration = tableFile.addInterface({
        name: initializerName,
        isExported: true
      });
      for (const column of tableData.columns) {
        const propertyCanBeNull = !column.query.includes("NOT NULL");
        const propertyHasDefaultValue = column.query.includes("DEFAULT");
        const isPropertyOptional = propertyHasDefaultValue || propertyCanBeNull;
        let tsType = sql_to_ts_type_default(column.type, propertyCanBeNull);
        if (column.name.endsWith("_id"))
          tsType = snake_to_pascal_default(column.name);
        const injectedTypeComment = column.comments.find((comment) => comment.comment.includes("@type:"));
        if (injectedTypeComment) {
          const typeToInject = injectedTypeComment.comment.split("@type:")[1].trim();
          tsType = typeToInject;
          tableFile.insertImportDeclaration(0, {
            moduleSpecifier: `${injectedTypesDirectory}/${typeToInject}`,
            defaultImport: typeToInject
          });
        }
        tableInterfaceDeclaration.addProperty({
          name: column.name,
          type: tsType
        });
        tableInterfaceInitializerDeclaration.addProperty({
          name: column.name,
          type: tsType,
          hasQuestionToken: isPropertyOptional
        });
      }
      const interfaceImportDeclaration = schemaIndexFile.addImportDeclaration({
        moduleSpecifier: `./${pascaledTableName}`,
        defaultImport: pascaledTableName
      });
      interfaceImportDeclaration.addNamedImport({
        name: initializerName
      });
      modelTypeMapDeclaration.addProperty({
        name: tableName,
        type: pascaledTableName
      });
      initializermodelTypeMapDeclaration.addProperty({
        name: tableName,
        type: initializerName
      });
      schemaIndexFileExportDeclaration.addNamedExports([
        pascaledTableName,
        initializerName
      ]);
      tableFile.saveSync();
    }
    schemaIndexFile.saveSync();
  }
  const moduleDeclaration = knexFile.addModule({
    name: '"knex/types/tables"',
    hasDeclareKeyword: true,
    declarationKind: import_ts_morph.ModuleDeclarationKind.Module
  });
  moduleDeclaration.addInterface({
    name: "Tables",
    extends: isPrimarySchemaNameValid ? [snake_to_pascal_default(primarySchemaName) + "ModelTypeMap"] : ["PublicModelTypeMap"]
  });
  const addInterfaceTemplates = prefixedKnexFileImportAliases.map((alias) => ({
    name: "Tables",
    extends: alias
  }));
  moduleDeclaration.addInterfaces(addInterfaceTemplates);
  indexFile.saveSync();
  knexFile.saveSync();
  const filePaths = project.getFileSystem().globSync(["**/*.ts"]);
  const fsObj = {};
  for (const filePath of filePaths) {
    fsObj[`.${filePath}`] = import_prettier.default.format(project.getFileSystem().readFileSync(filePath), {
      semi: false,
      parser: "typescript"
    });
  }
  return fsObj;
};
var tree_to_typescript_models_default = treeToTypescriptModels;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  treeToTypescriptModels
});
//# sourceMappingURL=index.js.map